import sys
# TODO BEFORE GOING LIVE ADD ALL ANYTOWN FILES INTO THIS PROJECT DIRECTORY
PATH_TO_ANYTOWN = '../anytown'
sys.path.append(PATH_TO_ANYTOWN)

from game import Game as Sim
from communicator import Communicator
import random
import string

# TODO LIST GRAVESTONES IN THE CEMETERY


NUMERAL_TO_WORD = {
    1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five',
    6: 'six', 7: 'seven', 8: 'eight', 9: 'nine', 10: 'ten',
    11: 'eleven', 12: 'twelve', 13: 'thirteen', 14: 'fourteen',
    15: 'fifteen', 16: 'sixteen', 17: 'seventeen',
    18: 'eighteen', 19: 'nineteen', 20: 'twenty',
}


class Game(object):
    """A Bad News gameplay instance."""

    def __init__(self, offline_mode=False):
        """Initialize a Game object."""
        if offline_mode:
            print "Okay. Preparing for single-player mode."
        self.sim = Sim()  # A city simulation generated by game.py
        try:
            self.sim.establish_setting()
        except KeyboardInterrupt:  # Allows game master to cut off worldgen early
            pass
        print "\nPreparing for gameplay..."
        self.sim.enact_no_fi_simulation()
        self.city = self.sim.city
        self.offline_mode = offline_mode  # Whether James is playtesting, in which case don't show hidden knowledge
        self.player = Player(game=self)
        self.deceased_character = self._select_deceased_character()
        self.nok = self.next_of_kin = self._determine_all_valid_next_of_kin()
        self.player.location = self.deceased_character.location
        # A communicator facilitates communication between the simulation and various game interfaces
        if not offline_mode:
            self.communicator = Communicator(game=self)
        else:
            self.communicator = None
        self._compose_opening_exposition()
        self._simulate_the_death()  # Called after the opening exposition is composed because of ' (deceased)' modifier
        self._init_set_up_helper_attributes()

    def _init_set_up_helper_attributes(self):
        """Set all helper attributes that pertain solely to this gameplay experience."""
        for person in self.city.residents|self.city.departed|self.city.deceased:
            person.temp_address_number = -1
            person.matches = [p for p in person.mind.mental_models if p.type == "person"]  # Matches to a mind query
            person.earlier_matches = []  # Allows going back to the last good set of matches after narrowing too far
            person.hinges = []  # Allows use of address numbers with hinges

    def _select_deceased_character(self):
        """Prepare the soon-to-be deceased character whose next-of-kin the
        player will be tasked with notifying.

        Currently, this method just randomly picks a person who has had an occupation at some
        point, has both friends and extended family in town, and is currently home alone.
        """
        potential_selections = [
            p for p in self.city.residents if p.location is p.home and
            len(p.location.people_here_now) == 1 and
            p.occupations and
            p.friends and
            p.greatgrandparents | p.grandparents | p.aunts | p.uncles | p.nieces | p.nephews | p.cousins
        ]
        return random.choice(potential_selections)

    def _simulate_the_death(self):
        """Simulate the death of the deceased character without actually killing them."""
        # Don't actually kill the character, just remove them from the simulation
        # by removing them from the 'residents' attribute of the gameplay city;
        # if we kill the character, a bunch of issues arise
        self.city.residents.remove(self.deceased_character)
        # self.deceased_character.location.people_here_now.remove(self.deceased_character)
        self.deceased_character.alive = False  # Crucially we do not call .die() method here

    def _determine_all_valid_next_of_kin(self):
        """Determine all the characters in town who could be successfully notified as the next of kin."""
        # Spouse
        if self.deceased_character.spouse and self.deceased_character.spouse.present:
            return [self.deceased_character.spouse]
        # Parents
        if self.deceased_character.parents and any(p for p in self.deceased_character.parents if p.present):
            return [p for p in self.deceased_character.parents if p.present]
        # Kids
        if self.deceased_character.kids and any(k for k in self.deceased_character.kids if k.present):
            return [k for k in self.deceased_character.kids if k.present]
        # Siblings
        if self.deceased_character.siblings and any(s for s in self.deceased_character.siblings if s.present):
            return [s for s in self.deceased_character.siblings if s.present]
        # Extended family (greatgrandparents, grandparents, aunts, uncles, cousins, nieces, nephews)
        if self.deceased_character.extended_family and any(
                ef for ef in self.deceased_character.extended_family if ef.present
        ):
            return [ef for ef in self.deceased_character.extended_family if ef.present]

    def _compose_opening_exposition(self):
        """Render the initial exposition that opens the game."""
        opening_exposition = (
            "It is {nighttime_or_daytime}, {date}. You are alone in {a_house_or_apartment} at {address} "
            "in the town of {city_name}, pop. {city_pop}. A deceased person lies before you. "
            "{pronoun} is {description}. You must locate {possessive} next of kin and inform "
            "that person of this death.".format(
                nighttime_or_daytime='nighttime' if self.sim.time_of_day == 'night' else 'daytime',
                date=self.sim.date[7:] if self.sim.time_of_day == 'day' else self.sim.date[9:],
                a_house_or_apartment="a house" if self.player.location.house else "an apartment",
                address=self.player.location.address,
                city_name=self.city.name,
                city_pop=self.city.population,
                pronoun=self.deceased_character.pronoun.capitalize(),
                description=self.deceased_character.description,
                possessive=self.deceased_character.possessive
            )
        )
        if self.offline_mode:
            print '\n{}\n'.format(opening_exposition)
        else:
            # Set this now and it will display on the player interface when
            # 'begin()' is called -- otherwise, we could screw up the interface
            # of a game already in progress while this sim is being prepared
            self.communicator.player_exposition = opening_exposition

    def advance_timestep(self):
        """Advance to the next timestep."""
        self.sim.enact_no_fi_simulation()

    def begin(self):
        """Start rendering the player and actor interfaces."""
        self.communicator.update_player_interface()
        self.communicator.update_actor_interface()


class Player(object):
    """A collection of data and affordances surrounding a player's interaction with a Bad News game world."""

    def __init__(self, game):
        """Initialize a Player object."""
        self.game = game
        self.city = game.city
        self.location = None  # Gets set by game
        self.outside = False  # Since you start in the deceased character's home
        self.places_i_have_been = []
        self.people_i_know_by_name = set()
        self.houses_i_know_by_name = set()
        self.salient_person_who_lives_in_a_house = {}
        self.last_address_i_heard = None
        self.last_unit_number_i_heard = None
        self.last_block_i_heard = None
        self.interlocutor = None
        self.subject_of_conversation = None  # Character whom player and interlocutor are currently talking about
        self.current_list_index = 0  # Facilitates ask_to_list methods
        self.refrain = ()  # Features they keep asking about

    @property
    def buildings_on_this_block(self):
        """Return a ask_to_list of the buildings on the player's current block."""
        block = self.location if self.location.type == 'block' else self.location.block
        return [b for b in self.city.buildings if b.block is block]

    def goto(self, address=None):
        """Move the player to a location with the given address.

        If no location exists at this address, move them simply to the associated block.
        """
        # Since this method is called when a player's location changes, it also
        # makes sense to end the character's current conversation, if any, because
        # usually this will co-occur with a command to move locations
        self.end_conversation()
        if not address:
            address = self.last_address_i_heard
        try:
            if ' (Unit' in address:
                address = address.split(' (Unit')[0]
            house_number = int(address[:3])
            street_object = self._find_street_object(address)
            self.location = next(
                b for b in self.city.buildings if b.house_number == house_number and
                b.block.street is street_object
            )
            self.outside = True
            self.places_i_have_been.append(self.location)
            self.observe()
        except StopIteration:
            # Arrive then at that block
            house_number = int(address[:3])
            block_number = int(address[0] + '00')
            street_object = self._find_street_object(address)
            block_object = next(b for b in self.city.blocks if b.number == block_number and b.street is street_object)
            if self.game.offline_mode:
                print "Arriving at the {}, you find no building with the house number {}.\n".format(
                    block_object, house_number
                )
                exposition_prefix = None
            else:
                exposition_prefix = "Arriving at the {}, you find no building with the house number {}.".format(
                    block_object, house_number
                )
            self.goto_block(block=block_object, exposition_prefix=exposition_prefix)

    def _find_street_object(self, address):
        """Complete a potentially abridged street name."""
        street_name = address[4:].lower()
        if street_name[-3:] == "ave":
            street_name += 'nue'
        elif street_name[-4:] == "ave.":
            street_name = street_name[:-1] + 'nue'
        elif street_name[-2:] == 'st':
            street_name += 'reet'
        elif street_name[-4:] == "st.":
            street_name = street_name[:-1] + 'reet'
        street_object = next(s for s in self.city.streets if s.name.lower() == street_name.lower())
        return street_object

    def go_downtown(self):
        """Go to the block where downtown is."""
        self.goto_block(block=self.city.downtown.block)

    def goto_block(self, block=None, exposition_prefix=None):
        """Move the character to the given block."""
        # Since this method is called when a player's location changes, it also
        # makes sense to end the character's current conversation, if any, because
        # usually this will co-occur with a command to move locations
        self.end_conversation()
        if not block:
            block = self.last_block_i_heard
        if type(block) == str:
            try:
                block = next(b for b in self.city.blocks if str(block) == b)
            except StopIteration:
                raise Exception('There is no {}'.format(block))
        self.location = block
        self.outside = True
        self.observe(exposition_prefix=exposition_prefix)

    def goto_co(self, business_name):
        """Go to the business in town with the given name."""
        business = next(c for c in self.city.companies if c.name == business_name)
        self.goto(business.address)

    def goto_nearest(self, business_type, that_i_havent_been_to=False):
        """Go to the nearest business of the given type."""
        businesses_of_that_type = self.city.businesses_of_type(business_type)
        if that_i_havent_been_to:
            businesses_of_that_type = list(set(businesses_of_that_type)-set(self.places_i_have_been))
        if businesses_of_that_type:
            if self.location.__class__.__name__ == 'Block':
                lot_i_am_on = random.choice(list(self.location.lots))
            else:
                lot_i_am_on = self.location.lot
            closest_business = min(
                businesses_of_that_type,
                key=lambda bar: self.city.distance_between(lot_i_am_on, bar.lot)
            )
            self.goto(closest_business.address)
        else:
            print "\nThere are no businesses of that type in {}.\n".format(
                self.city.name
            )

    def goto_bar(self):
        """Go to the closest bar in town."""
        self.goto_nearest('Bar')

    def goto_school(self):
        """Go to the K-12 school in town."""
        self.goto(self.city.school.address)

    def goto_another(self, business_type):
        """Go to the nearest business of the given type that you haven't been to yet."""
        self.goto_nearest(business_type=business_type, that_i_havent_been_to=True)

    def goback(self):
        """Go back to the last place you were at."""
        # Since this method is called when a player's location changes, it also
        # makes sense to end the character's current conversation, if any, because
        # usually this will co-occur with a command to move locations
        self.end_conversation()
        self.goto(self.places_i_have_been[-2].address)

    def move(self, direction):
        """Move to an adjacent block."""
        # Since this method is called when a player's location changes, it also
        # makes sense to end the character's current conversation, if any, because
        # usually this will co-occur with a command to move locations
        self.end_conversation()
        if self.location.type != 'block':
            self.location = self.location.block
        try:
            direction = direction.lower()
        except AttributeError:  # int or something weird was passed as direction and will get caught anyway
            pass
        available_directions = ('n', 's') if self.location.street.direction in ('N', 'S') else ('e', 'w')
        if direction not in ('n', 'e', 's', 'w'):
            print "\nThat is not a valid direction. Please choose from among the following options: N, S, E, W.\n"
        elif direction not in available_directions:
            direction_to_name = {'w': 'west', 'e': 'east', 's': 'south', 'n': 'north'}
            print "\n{street_name} runs {direction1} to {direction2}.\n".format(
                street_name=self.location.street.name,
                direction1=direction_to_name[available_directions[0]],
                direction2=direction_to_name[available_directions[1]],
            )
        else:
            index_of_this_block_on_street = self.location.street.blocks.index(self.location)
            index_of_new_block = (
                index_of_this_block_on_street+1 if direction in ('n', 'e') else index_of_this_block_on_street-1
            )
            if index_of_new_block < 0 or index_of_new_block == len(self.location.street.blocks):
                direction_to_adj = {'w': 'western', 'e': 'eastern', 's': 'southern', 'n': 'northern'}
                print "\nYou are already at the {direction_adj} terminus of {street_name}.\n".format(
                    direction_adj=direction_to_adj[direction],
                    street_name=self.location.street.name
                )
            else:
                # Go to the new block
                new_block = self.location.street.blocks[index_of_new_block]
                self.goto_block(block=new_block)

    def approach(self, house_number=None):
        """Move the player to the building on her current block with the given house number."""
        if house_number < 100:
            print 'I think you meant to call address(), not approach().'
        elif not house_number:
            print "\nYou need to specify a house number to approach.\n"
        else:
            if self.location.__class__.__name__ != 'Block':
                self.location = self.location.block
            building_to_approach = None
            if len(self.location.buildings) == 1:
                building_to_approach = list(self.location.buildings)[0]
            else:
                try:
                    building_to_approach = next(b for b in self.location.buildings if b.house_number == house_number)
                except StopIteration:
                    print "\nThere is no building on this block with the house number {}\n".format(house_number)
            if building_to_approach:
                self.location = building_to_approach
                self.outside = True
                self.places_i_have_been.append(self.location)
                self.observe()

    def approach_apt(self, unit_number=None):
        """Move the player to the unit of the apartment she is currently outside with the given unit number."""
        if self.location.__class__.__name__ == "Apartment":
            self.location = self.location.complex
        if not unit_number:
            unit_number = self.last_unit_number_i_heard
        self.location = self.location.units[unit_number-1]
        self.outside = True  # Make sure elsewhere to check for outside + location being an apartment unit
        self.observe()

    def enter(self, house_number=None, let_in=False):
        """Enter a building."""
        if not house_number:
            # Then attempt to enter the building you are outside of
            if not self.location.locked or let_in:
                self.outside = False
                self.observe()
            else:
                print '\nThe gate is locked.\n' if self.location.lot.tract else '\nThe door is locked.\n'
        else:
            if self.location.__class__.__name__ != 'Block':
                self.location = self.location.block
            building_to_approach = next(b for b in self.location.buildings if b.house_number == house_number)
            self.location = building_to_approach
            if not self.location.locked or let_in:
                self.outside = False
                self.observe()
            else:
                print '\nThe gate is locked.\n' if self.location.lot.tract else '\nThe door is locked.\n'

    def enter_apt(self, unit_number=None):
        """Enter a building."""
        if not unit_number:
            # Then attempt to enter the apartment unit you are standing outside of
            if not self.location.locked:
                self.outside = False
                self.observe()
            else:
                print 'The door is locked.'
        else:
            if self.location.__class__.__name__ != 'ApartmentComplex':
                self.location = self.location.complex
            apartment_unit_to_approach = next(a for a in self.location.units if a.unit_number == unit_number)
            self.location = apartment_unit_to_approach
            if not self.location.locked:
                self.outside = False
                self.observe()
            else:
                print 'The door is locked.'

    def exit(self):
        """Exit a building."""
        # Since this method is called when a player's location changes, it also
        # makes sense to end the character's current conversation, if any, because
        # usually this will co-occur with a command to move locations
        self.end_conversation()
        self.outside = True
        self.observe()

    def go_outside(self):
        """Go into the street and the observe the block you are on."""
        # Since this method is called when a player's location changes, it also
        # makes sense to end the character's current conversation, if any, because
        # usually this will co-occur with a command to move locations
        self.end_conversation()
        self.outside = True
        self.location = self.location.block
        self.observe()

    def observe(self, exposition_prefix=None, update_enumeration_only=False):
        """Describe the player's current setting."""
        if self.outside:  # Interior scenes
            if self.location.type == 'block':
                exposition, enumeration = self._describe_the_block_player_is_on()
            elif self.location.__class__.__name__ == 'House':
                exposition = self._describe_house_exterior()
                enumeration = ''
            elif self.location.__class__.__name__ == 'Apartment':
                exposition = self._describe_apartment_unit_exterior()
                enumeration = ''
            elif self.location.__class__.__name__ == 'ApartmentComplex':
                exposition, enumeration = self._describe_apartment_complex_exterior()
            else:  # Business
                exposition = self._describe_business_exterior()
                enumeration = ''
        else:  # Exterior scenes
            if self.location.type == 'residence':
                exposition, enumeration = self._describe_home_interior()
            else:
                exposition, enumeration = self._describe_business_interior()
        if self.game.offline_mode:
            if enumeration:
                exposition += '\n' + enumeration
            print "\n{}\n".format(exposition)
        else:
            # Update the player interface; sometimes an exposition prefix
            # may propagate up from other methods to this one -- this is just
            # some fragment of text that should precede the observational text
            if exposition_prefix:
                exposition = exposition_prefix + '<br><br>' + exposition
            exposition = exposition.replace('\n', '<br>')
            if not update_enumeration_only:
                # update_enumeration_only will be True when remember() calls this
                # method to update the enumeration to include an NPC's name
                self.game.communicator.player_exposition = exposition
            self.game.communicator.player_exposition_enumeration = enumeration
            self.game.communicator.update_player_interface()

    def _describe_the_block_player_is_on(self):
        """Describe the block that the player is on."""
        buildings_on_this_block = [lot.building for lot in self.location.lots if lot.building]
        if buildings_on_this_block:
            buildings_enumeration = self._describe_buildings_on_block()
            if len(buildings_on_this_block) > 1:
                exposition = "You are on the {}. There are {} buildings here:".format(
                    self.location, NUMERAL_TO_WORD[len(buildings_on_this_block)], buildings_enumeration
                )
            else:
                exposition = "You are on the {}. There is one building here:".format(
                    self.location, buildings_enumeration
                )
        else:
            exposition = "You are on the {}. There are no buildings here.".format(self.location)
            buildings_enumeration = ''
        return exposition, buildings_enumeration

    def _describe_buildings_on_block(self):
        """Generate a pretty-printable description of buildings on the block the player is on."""
        line_prefix = '\n\t' if self.game.offline_mode else '<br><b>'
        tab = '\t' if self.game.offline_mode else '</b><br>'
        description = ""
        buildings_on_this_block = [lot.building for lot in self.location.lots if lot.building]
        for building in buildings_on_this_block:
            description += line_prefix
            if building.__class__.__name__ in ('Bar', 'Restaurant'):
                description += '{}{}A {} whose sign reads: "{}"'.format(
                    building.lot.house_number,
                    tab,
                    building.__class__.__name__.lower(), building.sign
                )
            elif building.__class__.__name__ == 'House':
                if self.game.sim.time_of_day == 'night':
                    lights_on = ' with its lights on' if building.people_here_now else ' with its lights off'
                else:
                    lights_on = ''
                if building in self.houses_i_know_by_name:
                    lights_on = ','+lights_on if lights_on else ''
                    "{}{}{}'s house{}".format(
                        building.lot.house_number,
                        tab,
                        self.salient_person_who_lives_in_a_house[building].name,
                        lights_on
                    )
                else:
                    description += '{}{}A private residence{}'.format(
                        building.lot.house_number,
                        tab,
                        lights_on
                    )
            else:  # A business that's not a bar or restaurant
                if building.__class__.__name__ == 'Farm':
                    description += '{house_number}{tab}A farm'.format(
                        house_number=building.house_number,
                        tab=tab,
                    )
                else:
                    description += '{house_number}{tab}A {gated_area_or_company} whose sign reads: "{sign}"'.format(
                        house_number=building.lot.house_number,
                        tab=tab,
                        gated_area_or_company='gated area' if building.lot.tract else 'company',
                        sign=building.sign
                    )
        return description

    def _describe_house_exterior(self):
        """Describe the house whose doorstep the player is standing on."""
        if self.location in self.houses_i_know_by_name:
            whose_house = "{person_i_know_lives_here}'s house".format(
                person_i_know_lives_here=self.salient_person_who_lives_in_a_house[self.location].name
            )
        else:
            whose_house = "a house"
        if len(self.location.people_here_now) > 3:
            noise_of_activity_inside = "a bustle of activity inside"
        elif self.location.people_here_now:
            noise_of_activity_inside = "a faint noise inside"
        else:
            noise_of_activity_inside = "nothing inside"
        if self.game.sim.time_of_day == "night":
            exposition = (
                "You are at the doorstep of {whose_house} at {address}. "
                "Its lights are {lights_on}, its door is {door_locked}, and you hear {noise_of_activity_inside}.".format(
                    whose_house=whose_house,
                    address=self.location.address,
                    lights_on="on" if self.location.people_here_now else "off",
                    door_locked="locked" if self.location.locked else "unlocked",
                    noise_of_activity_inside=noise_of_activity_inside
                )
            )
        else:
            exposition = (
                "You are at the doorstep of {whose_house} at {address}. "
                "Its door is {door_locked} and you hear {noise_of_activity_inside}.".format(
                    whose_house=whose_house,
                    address=self.location.address,
                    door_locked="locked" if self.location.locked else "unlocked",
                    noise_of_activity_inside=noise_of_activity_inside
                )
            )
        return exposition

    def _describe_apartment_unit_exterior(self):
        """Describe the apartment unit whose door the player is standing at."""
        if self.location in self.houses_i_know_by_name:
            whose_apartment = "{person_i_know_lives_here}'s apartment, unit #{unit_number}".format(
                person_i_know_lives_here=self.salient_person_who_lives_in_a_house[self.location].name,
                unit_number=self.location.unit_number
            )
        else:
            whose_apartment = "unit #{unit_number}".format(unit_number=self.location.unit_number)
        if len(self.location.people_here_now) > 3:
            noise_of_activity_inside = "a bustle of activity inside"
        elif self.location.people_here_now:
            noise_of_activity_inside = "a faint noise inside"
        else:
            noise_of_activity_inside = "nothing"
        if self.location.locked and self.location.people_here_now:
            conjunction = ', but'
        else:
            conjunction = ' and'
        exposition = (
            "You are in a hallway standing outside the door of {whose_apartment} of {apartment_complex}. "
            "Its door is {door_locked}{conjunction} you hear {noise_of_activity_inside}.".format(
                whose_apartment=whose_apartment,
                apartment_complex=self.location.complex.name,
                door_locked="locked" if self.location.locked else "unlocked",
                conjunction=conjunction,
                noise_of_activity_inside=noise_of_activity_inside
            )
        )
        return exposition

    def _describe_apartment_complex_exterior(self):
        """Describe the apartment complex, particularly its intercom system, that the player is outside of."""
        try:
            janitor_in_lobby = next(e for e in self.location.working_right_now if e[0] == 'janitor')
        except StopIteration:
            janitor_in_lobby = None
        if janitor_in_lobby:
            lobby_str = ", but there is a janitor in the lobby"
        else:
            lobby_str = " and the lobby is empty"
        exposition = (
            "You are outside {complex_name} at {address}. Its entrance is locked{lobby_str}. There "
            "are {n_options} options listed on the intercom system:".format(
                complex_name=self.location.name,
                address=self.location.address,
                lobby_str=lobby_str,
                n_options=len(self.location.units)+1,
            )
        )
        enumeration = self._describe_apartment_complex_intercom()
        return exposition, enumeration

    def _describe_apartment_complex_intercom(self):
        """Describe the apartment complex's intercom system, listing units and names."""
        line_prefix = '\n\t' if self.game.offline_mode else '<br><b>'
        tab = '\t' if self.game.offline_mode else '</b><br>'
        intercom_description = ""
        for unit in self.location.units:
            if unit.owners:
                all_surnames_among_owners = {owner.last_name for owner in unit.owners}
                owner_str = '/'.join(all_surnames_among_owners)
            else:
                owner_str = '--'
            intercom_description += '{line_prefix}#{unit_no}{tab}{owners_surnames}'.format(
                line_prefix=line_prefix,
                unit_no=unit.unit_number,
                tab=tab,
                owners_surnames=owner_str
            )
        intercom_description += "\n{line_prefix}#99{tab}Office".format(
            line_prefix=line_prefix,
            tab=tab
        )
        return intercom_description

    def _describe_business_exterior(self):
        """Describe the business a player is outside of."""
        if len(self.location.people_here_now) > 8:
            n_people_inside = "many people"
        elif len(self.location.people_here_now) > 4:
            n_people_inside = "several people"
        elif len(self.location.people_here_now) > 1:
            n_people_inside = "a few people"
        elif self.location.people_here_now:
            # A single person -- if it's a janitor, be more specific and
            # explicitly say that
            if self.location.working_right_now and self.location.working_right_now[0][0] == 'janitor':
                n_people_inside = "a janitor"
            else:
                n_people_inside = "a person"
        else:
            n_people_inside = "no one"
        if self.location.locked and self.location.people_here_now:
            conjunction = ', but'
        else:
            conjunction = ' and'
        exposition = (
            "You are at the entrance of {business_name} at {address}. "
            "Its {gate_or_door} is {door_locked}{conjunction} you see {n_people_inside} "
            "{inside_or_on_premises}.".format(
                business_name=self.location.name if self.location.__class__.__name__ != 'Farm' else 'a farm',
                address=self.location.address,
                gate_or_door="gate" if self.location.lot.tract else "door",
                door_locked="locked" if self.location.locked else "unlocked",
                conjunction=conjunction,
                n_people_inside=n_people_inside,
                inside_or_on_premises="on the premises" if self.location.lot.tract else "inside"
            )
        )
        return exposition

    def _describe_home_interior(self):
        """Describe the interior of a house that the player is in."""
        if self.location in self.houses_i_know_by_name:
            house_noun_phrase = "the {house_or_apartment} of {person_i_know_lives_here}".format(
                house_or_apartment="home" if self.location.house else "apartment",
                person_i_know_lives_here=self.salient_person_who_lives_in_a_house[self.location].name
            )
        else:
            house_noun_phrase = "a {house_or_apartment}".format(
                house_or_apartment="home" if self.location.house else "apartment"
            )
        if len(self.location.people_here_now) > 14:
            people_here_intro = "There are very many people here:".format(
                len(self.location.people_here_now)
            )
        elif len(self.location.people_here_now) > 7:
            people_here_intro = "There are many people here:"
        elif len(self.location.people_here_now) > 1:
            people_here_intro = "There are {number_word} people here:".format(
                number_word=NUMERAL_TO_WORD[len(self.location.people_here_now)]
            )
        elif self.location.people_here_now:
            people_here_intro = "There is a single person here:"
        else:
            people_here_intro = "There is no one here."
        exposition = (
            "You are inside {house_noun_phrase} at {address}. "
            "{people_here_intro}".format(
                house_noun_phrase=house_noun_phrase,
                address=self.location.address,
                people_here_intro=people_here_intro
            )
        )
        enumeration = self._describe_people_in_home()
        return exposition, enumeration

    def _describe_people_in_home(self):
        """Describe the individuals currently situated in a residence that the player is in."""
        line_prefix = '\n\t' if self.game.offline_mode else '<br><b>'
        tab = '\t' if self.game.offline_mode else '</b><br>'
        people_present_description = ""
        people_here_now = list(self.location.people_here_now)
        for i in xrange(len(people_here_now)):
            person = people_here_now[i]
            person.temp_address_number = i
            if person in self.people_i_know_by_name:
                people_present_description += '{line_prefix}{i}{tab}{persons_name}'.format(
                    line_prefix=line_prefix,
                    i=person.temp_address_number,
                    tab=tab,
                    persons_name=person.name
                )
            else:
                people_present_description += '{line_prefix}{i}{tab}{age_gender} with {appearance}'.format(
                    line_prefix=line_prefix,
                    i=person.temp_address_number,
                    tab=tab,
                    age_gender=person.age_and_gender_description,
                    appearance=person.basic_appearance_description
                ).capitalize()
        return people_present_description

    def _describe_business_interior(self):
        """Describe the interior of a business that the player is in."""
        if len(self.location.people_here_now) > 14:
            people_here_intro = "There are very many people here:".format(
                len(self.location.people_here_now)
            )
        elif len(self.location.people_here_now) > 7:
            people_here_intro = "There are many people here:"
        elif len(self.location.people_here_now) > 1:
            people_here_intro = "There are {number_word} people here:".format(
                number_word=NUMERAL_TO_WORD[len(self.location.people_here_now)]
            )
        elif self.location.people_here_now:
            people_here_intro = "There is a single person here:"
        else:
            people_here_intro = "There is no one here."
        exposition = (
            "You are {inside_or_on_premises_of} {business_name} at {address}. "
            "{people_here_intro}".format(
                inside_or_on_premises_of='on the premises of' if self.location.lot.tract else 'inside',
                business_name=self.location.name if self.location.__class__.__name__ != 'Farm' else 'a farm',
                address=self.location.address,
                people_here_intro=people_here_intro
            )
        )
        enumeration = self._describe_people_in_business()
        return exposition, enumeration

    def _describe_people_in_business(self):
        """Describe the individuals currently situated in a residence that the player is in."""
        line_prefix = '\n\t' if self.game.offline_mode else '<br><b>'
        tab = '\t' if self.game.offline_mode else '</b><br>'
        people_present_description = ""
        people_here_now = list(self.location.people_here_now)
        # List people working here first (sorted by job level)
        people_here_now.sort(
            key=lambda p: (p.routine.working,
                           0 if not p.occupation or not p.routine.working else p.occupation.level),
            reverse=True
        )
        for i in xrange(len(people_here_now)):
            person = people_here_now[i]
            person.temp_address_number = i
            if (self.game.sim.time_of_day == 'day' and self.location.__class__.__name__ == 'School' and
                    person.whereabouts.date[(self.game.sim.ordinal_date, 0)].occasion == 'school'):
                occupation_if_working = ' (student)'
            else:
                occupation_if_working = ' ({})'.format(person.occupation.vocation) if person.routine.working else ''
            if person in self.people_i_know_by_name:
                people_present_description += '{line_prefix}{i}{tab}{persons_name}{occupation_if_working}'.format(
                    line_prefix=line_prefix,
                    i=person.temp_address_number,
                    tab=tab,
                    persons_name=person.name,
                    occupation_if_working=occupation_if_working

                )
            else:
                people_present_description += (
                    '{line_prefix}{i}{tab}{age_gender} with {appearance}{occupation_if_working}'.format(
                        line_prefix=line_prefix,
                        i=person.temp_address_number,
                        tab=tab,
                        age_gender=person.age_and_gender_description,
                        appearance=person.basic_appearance_description,
                        occupation_if_working=occupation_if_working
                    ).capitalize()
                )
        return people_present_description

    def address(self, addressee=None):
        """Address person with the given name here, or else the only person here."""
        if addressee is not None:
            if type(addressee) == str:
                name = addressee
                address_number = None
            else:
                address_number = addressee
                name = None
        else:
            name = None
            address_number = None
        if self.location.people_here_now:
            if len(self.location.people_here_now) == 1:
                self.interlocutor = list(self.location.people_here_now)[0]
                self.game.communicator.update_actor_interface()
                exposition = "You are talking to {age_and_gender_nominal} with {appearance} [{i}]. {nearby}".format(
                    age_and_gender_nominal=self.interlocutor.age_and_gender_description,
                    appearance=self.interlocutor.basic_appearance_description,
                    i='<b>{}</b>'.format(self.interlocutor.temp_address_number),
                    nearby="The following people are still nearby:" if not self.game.offline_mode else ''
                )
            else:
                if any(p for p in self.location.people_here_now if p.name == name):
                    self.interlocutor = next(p for p in self.location.people_here_now if p.name == name)
                    self.game.communicator.update_actor_interface()
                    exposition = "You are talking to {age_and_gender_nominal} with {appearance} [{i}]. {nearby}".format(
                        age_and_gender_nominal=self.interlocutor.age_and_gender_description,
                        appearance=self.interlocutor.basic_appearance_description,
                        i='<b>{}</b>'.format(self.interlocutor.temp_address_number),
                        nearby="The following people are still nearby:" if not self.game.offline_mode else ''
                    )
                elif any(p for p in self.location.people_here_now if p.temp_address_number == address_number):
                    self.interlocutor = next(
                        p for p in self.location.people_here_now if p.temp_address_number == address_number
                    )
                    self.game.communicator.update_actor_interface()
                    exposition = "You are talking to {age_and_gender_nominal} with {appearance} [{i}]. {nearby}".format(
                        age_and_gender_nominal=self.interlocutor.age_and_gender_description,
                        appearance=self.interlocutor.basic_appearance_description,
                        i='<b>{}</b>'.format(self.interlocutor.temp_address_number),
                        nearby="The following people are still nearby:" if not self.game.offline_mode else ''
                    )
                else:
                    exposition = "I'm not sure whom you met.".format(name)
        else:
            exposition = 'No one is here.'.format(name)
        if self.game.offline_mode:
            print '\n{exposition}\n'.format(exposition=exposition)
        else:
            self.game.communicator.player_exposition = exposition
            self.game.communicator.update_player_interface()

    def end_conversation(self):
        """Set the interlocutor back to None and update the actor interface accordingly."""
        if self.interlocutor:
            self.interlocutor = None
            self.game.communicator.update_actor_interface()

    def do_you_know(self, features_str, narrow=False):
        """Return a ask_to_list of all the mental models interlocutor has that match the given features.

        Features should be a ask_to_list of tuples, where the first element of each tuple is a feature
        type and the second element is the corresponding feature value, e.g., ('hair color',
        'brown') or ('first name', 'Paul').
        """
        if not features_str:
            features_str = self.refrain
        else:
            self.refrain = features_str
        features = self._parse_feature_strings(features_str)
        # Build a lambda function that we will use to build a list of
        # all the people in interlocutor's mind that match the given features
        matches_description = (
            lambda mental_model: all(
                str(mental_model.get_facet_to_this_belief_of_type(feature[0])) == feature[1]
                for feature in features if feature
            )
        )
        pool_searching_in = self.interlocutor.mind.mental_models if not narrow else self.interlocutor.matches
        self.interlocutor.earlier_matches = list(self.interlocutor.matches)
        self.interlocutor.matches = [
            p for p in pool_searching_in if
            p.type == "person" and
            matches_description(self.interlocutor.mind.mental_models[p])
        ]
        if any(f for f in features if '_' in f):
            self.express_matches(underscore_warning=True)
        else:
            self.express_matches()

    @staticmethod
    def _parse_feature_strings(features):
        """Parse a set of feature strings to return a tuple of (feature_name, feature_value) tuples."""
        features = features.replace(' ', '')  # Remove whitespace
        features = features.split(',')  # Split on commas
        # First, try to parse as if a name was passed -- this is hacky, but allows a
        # nicely idiomatic default usage of do_you_know(name) while still allowing
        # the more general usage that I specify in the docstring
        if '=' not in features[0]:
            first_name, last_name = features[0].split()
            features_list = [('first name', first_name), ('last name', last_name)]
            return features_list
        # Otherwise, parse all the features specified in the feature strings
        feature_name_expansions = {
            's': 'sex', 'hc': 'hair color', 'hl': 'hair length', 'f': 'freckles', 'b': 'birthmark',
            't': 'tattoo', 'g': 'glasses', 'fhs': 'sideburns', 'fhsb': 'sideburns', 'fhg': 'goatee',
            'fhfb': 'full beard', 'fhsp': 'soul patch', 'fhm': 'mustache', 'sc': 'broad skin color',
            'ar': 'age range', 'gl': 'glasses', 'fn': 'first name', 'ln': 'last name', 'mn': 'middle name'
        }
        feature_value_expansions = {
            'bla': 'black', 'br': 'brown', 'bro': 'brown', 'blo': 'blonde', 'ma': 'middle-aged', 'y': 'yes', 'n': 'no',
            'm': 'male', 'f': 'female', 'l': 'long', 'md': 'medium', 's': 'short', 'b': 'bald', 'e': 'elderly',
            'o': 'older', 'i': 'infant', 't': 'toddler', 'g': 'gray', 'w': 'white', 'r': 'red'
        }
        features_list = []
        for feature in features:
            feature_name, feature_value = feature.lower().split('=')
            # Expand abbreviated tags
            if feature_name in feature_name_expansions:
                feature_name = feature_name_expansions[feature_name]
            if feature_value in feature_value_expansions:
                feature_value = feature_value_expansions[feature_value]
            # Fix common mistakes
            if feature_name == 'hair length' and feature_value == 'male':
                feature_value = 'medium'
            elif feature_name == 'age range' and feature_value == 'male':
                feature_value = 'middle-aged'
            elif feature_name == 'age range' and feature_value == 'yes':
                feature_value = 'young'
            # Throw an error for detected mistakes that can't be automatically fixed
            if feature_name == 'hair color' and feature_value in ('bald', 'bl'):
                raise Exception("You used the wrong abbreviation for the 'hair color' feature!")
            features_list.append((feature_name, feature_value))
        return features_list

    def express_matches(self, underscore_warning=False):
        """Express the number matches interlocutor found from the mind query."""
        # If a single match was found, make them the new subject of conversation;
        # further, if that person is at this very location right now, make that known
        if len(self.interlocutor.matches) == 1:
            if self.interlocutor.matches[0].location is self.location:
                if self.interlocutor.matches[0] is self.interlocutor:
                    and_they_are_right_here = " (and {pronoun} is me!)".format(
                        pronoun=self.interlocutor.matches[0].pronoun
                    )
                else:
                    and_they_are_right_here = " (and {pronoun} is here right now)".format(
                        pronoun=self.interlocutor.matches[0].pronoun
                    )
            else:
                and_they_are_right_here = ''
            print "\nFound a match{and_they_are_right_here}:".format(and_they_are_right_here=and_they_are_right_here)
            self.interlocutor.matches[0].temp_address_number = 999
            self.talk_about(address_number=999)
        else:
            print "\nFound {} matches.\n".format(len(self.interlocutor.matches))
            if underscore_warning:
                print '\nWarning: You put an underscore in one of the features.\n'

    def narrow(self, features_str):
        """Narrow the matches interlocutor has found by specifying additional features."""
        assert self.interlocutor.matches != [], "Cannot narrow an empty list."
        self.do_you_know(features_str, narrow=True)

    def pop_back(self):
        """Pop back to the last good set of matches after narrowing too far."""
        self.interlocutor.matches = list(self.interlocutor.earlier_matches)

    def ask_to_list(self, start_index=0, n_to_list=None):
        """Ask interlocutor to ask_to_list their potential matches to the player's question."""
        if not n_to_list:
            n_to_list = len(self.interlocutor.matches)
        print '\n'
        for i in xrange(start_index, start_index+n_to_list):
            match = self.interlocutor.matches[i]
            match.temp_address_number = i
            print "\t{i}\t{basic_description}".format(
                i=i,
                basic_description=self.interlocutor.mind.mental_models[match].basic_description
            )
            self.current_list_index = i
        print '\n'

    def list_a_few(self):
        """Ask interlocutor to list a few of their potential matches to the player's question."""
        self.ask_to_list(start_index=0, n_to_list=5)

    def list_a_few_more(self):
        """Ask interlocutor to list a few more of their potential matches to the player's question."""
        self.ask_to_list(start_index=self.current_list_index, n_to_list=5)

    def talk_about(self, address_number=None):
        """Change the subject of conversation to the person with the given address number."""
        self.subject_of_conversation = next(
            p for p in self.interlocutor.matches if p.temp_address_number == address_number
        )
        if not self.game.offline_mode:
            self.game.communicator.update_actor_interface()
            # self.interlocutor.mind.mental_models[self.subject_of_conversation].outline()
        if self.interlocutor.mind.mental_models[self.subject_of_conversation].relations_to_me:
            self.interlocutor.hinges = [
                self.interlocutor.mind.mental_models[self.subject_of_conversation].relations_to_me[0][1]
            ]
        else:
            self.interlocutor.hinges = []

    def talk_about_hinge(self, address_number=None):
        """Change the subject of conversation to the hinge between interlocutor and the current subject."""
        if address_number is None:
            self.subject_of_conversation = self.interlocutor.hinges[0]
        else:
            self.subject_of_conversation = next(
                p for p in self.interlocutor.hinges if p.temp_address_number == address_number
            )
        if not self.game.offline_mode:
            self.game.communicator.update_actor_interface()
            # self.interlocutor.mind.mental_models[self.subject_of_conversation].outline()
        if self.interlocutor.mind.mental_models[self.subject_of_conversation].relations_to_me:
            self.interlocutor.hinges = [
                self.interlocutor.mind.mental_models[self.subject_of_conversation].relations_to_me[0][1]
            ]
        else:
            self.interlocutor.hinges = []

    def how_do_you_know(self):
        """List data about interlocutor's relationship with subject, including all of subject's
        relations to interlocutor, which also facilitates setting a hinge as the new subject of conversation.
        """
        self.interlocutor.hinges = []
        print "\n"
        if self.subject_of_conversation in self.interlocutor.relationships:
            print self.interlocutor.relationships[self.subject_of_conversation].outline()
        else:
            print "Type: None"
        print '\nRelations:\n'
        temp_address_number = 0
        for relation, hinge in self.interlocutor.mind.mental_models[self.subject_of_conversation].relations_to_me:
            if hinge:
                self.interlocutor.hinges.append(hinge)
                hinge.temp_address_number = temp_address_number
            print '{temp_address_number}\t{relation}'.format(
                temp_address_number=temp_address_number if hinge else '',
                relation=relation
            )
            if hinge:
                temp_address_number += 1
        print '\n'

    def who_lives_in(self, house_or_unit_number=None):
        """Ask interlocutor if they know who lives in a neighboring home with the given house_or_unit_number."""
        # Pre-narrow the interlocutor's matches to all the people that live nearby them
        # currently (i.e., exclude former neighbors who died)
        self.interlocutor.earlier_matches = list(self.interlocutor.matches)
        self.interlocutor.matches = [
            p for p in self.interlocutor.mind.mental_models if p.type == 'person' and
            p.alive and
            p in self.interlocutor.neighbors
        ]
        if house_or_unit_number:  # Having default be None facilitates wrapper calls from who_lives_by_you()
            if house_or_unit_number > 99:  # Must be house number
                self.interlocutor.matches = [
                    p for p in self.interlocutor.matches if p.home.house and
                    p.home.house_number == house_or_unit_number
                ]
            else:  # Must be unit number
                self.interlocutor.matches = [
                    p for p in self.interlocutor.matches if p.home.apartment and
                    p.home.unit_number == house_or_unit_number
                ]
        self.express_matches()

    def who_lives_by_you(self):
        """Ask interlocutor if they know their neighbors."""
        self.who_lives_in(house_or_unit_number=None)

    def ask_about(self, feature_type):
        """Ask about the given feature of the current subject of conversation."""
        mental_model = self.interlocutor.mind.mental_models[self.subject_of_conversation]
        facet = mental_model.get_facet_to_this_belief_of_type(feature_type=feature_type)
        print '\n{feature_value} ({confidence})\n'.format(
            feature_value=facet if facet else '[forgot]' if facet == '' else '?',
            confidence='-' if not facet else facet.strength_str
        )

    def remember(self):
        """Remember the name of the person you are talking to."""
        self.people_i_know_by_name.add(self.interlocutor)
        self.observe(exposition_prefix=None, update_enumeration_only=True)

    def ring(self):
        """Print exposition surrounding the ringing of a doorbell."""
        answerer = self._determine_who_answers_buzzer_or_doorbell(dwelling_place=self.location)
        if answerer:
            self.interlocutor = answerer
            self.game.communicator.update_actor_interface()
        verb_phrase = 'comes to the gate' if self.location.lot.tract else 'answers the door'
        if answerer in self.people_i_know_by_name:
            exposition = '{answerer_name} {answers}.'.format(
                answerer_name=answerer.name,
                answers=verb_phrase
            ).capitalize()
        elif answerer:
            exposition = '{age_and_gender} with {appearance} {answers}.'.format(
                age_and_gender=answerer.age_and_gender_description.capitalize(),
                appearance=answerer.basic_appearance_description,
                answers=verb_phrase
            ).capitalize()
        else:
            exposition = 'No one {answers}.'.format(
                answers=verb_phrase
            )
        if self.game.offline_mode:
            print '\n{exposition}\n'.format(exposition=exposition)
        else:
            self.game.communicator.player_exposition = exposition
            self.game.communicator.update_player_interface()

    def knock(self):
        """Print exposition surrounding the knocking of a house's door."""
        self.ring()

    def buzz(self, unit_number):
        """Print exposition surrounding the buzzing of an apartment unit."""
        self.last_unit_number_i_heard = unit_number
        if unit_number == 99:
            answerer = self._buzz_apartment_complex_office()
        else:
            apartment_unit_buzzed = self.location.units[unit_number-1]
            answerer = self._determine_who_answers_buzzer_or_doorbell(
                dwelling_place=apartment_unit_buzzed
            )
        if answerer:
            self.interlocutor = answerer
            self.game.communicator.update_actor_interface()
            exposition = '{} speaks into the intercom.'.format(
                answerer.age_and_gender_description.capitalize()
            ).capitalize()
        else:
            self.interlocutor = None
            exposition = 'No one answers.'
        if self.game.offline_mode:
            print '\n{exposition}\n'.format(exposition=exposition)
        else:
            self.game.communicator.player_exposition = exposition
            self.game.communicator.update_player_interface()

    def _buzz_apartment_complex_office(self):
        """Buzz the office of an apartment complex.

        If a secretary is working, they will answer; else, if a landlord is working, they
        will answer; else, no one will answer.
        """
        # This buzzes the office -- if a secretary or landlord is working,
        # have them answer
        try:
            answerer = next(e for e in self.location.working_right_now if e[0] == 'secretary')[1]
        except StopIteration:
            try:
                answerer = next(e for e in self.location.working_right_now if e[0] == 'landlord')[1]
            except StopIteration:
                answerer = None
        return answerer

    @staticmethod
    def _determine_who_answers_buzzer_or_doorbell(dwelling_place):
        """Return a random person who is here to come to the door."""
        if not dwelling_place.people_here_now:
            return None
        else:
            # See if any adults who live here are home -- if any are, return the most
            # extroverted person among them
            adults_who_live_here_who_are_home = [
                p for p in dwelling_place.people_here_now if p.adult and p.home is dwelling_place
            ]
            if adults_who_live_here_who_are_home:
                return max(adults_who_live_here_who_are_home, key=lambda q: q.personality.extroversion)
            else:
                # See if any adults are here, and if any are, return the most extroverted of them
                adults_here = [p for p in dwelling_place.people_here_now if p.adult]
                if adults_here:
                    return max(adults_here, key=lambda p: p.personality.extroversion)
                else:
                    # See if anyone who lives here and is at least five years old is home; if
                    # there is, return the oldest one
                    people_here_who_live_here = [
                        p for p in dwelling_place.people_here_now if p.home is dwelling_place and
                        p.age > 4
                    ]
                    if people_here_who_live_here:
                        return max(people_here_who_live_here, key=lambda p: p.age)
                    else:
                        # See if anyone above age 4 is here; if there is, return the oldest one
                        people_here_above_age_four = [
                            p for p in dwelling_place.people_here_now if p.age > 4
                        ]
                        if people_here_above_age_four:
                            return max(people_here_above_age_four, key=lambda p: p.age)
                        else:
                            return None

    def wait(self):
        """Wait here until the next timestep."""
        self.game.advance_timestep()
        self.observe()

    def notify(self):
        """Notify interlocutor that the deceased person has died."""
        # Determine whether the notified person was a next of kin
        if self.interlocutor in self.game.next_of_kin:
            verdict = "You have successfully notified the next of kin. You win!"
        else:
            verdict = "You have notified the wrong person. You lose."
        # Express this outcome to the player
        if self.game.offline_mode:
            print verdict
        else:
            self.game.communicator.player_exposition = verdict
            self.game.communicator.player_exposition_enumeration = ''
            self.game.communicator.update_player_interface()

    @property
    def i(self):
        """Wrapper for self.interlocutor."""
        return self.interlocutor

    @property
    def s(self):
        """Wrapper for self.subject_of_conversation."""
        return self.subject_of_conversation

    def dyk(self, features_str):
        """A wrapper around do_you_know()."""
        self.do_you_know(features_str, narrow=False)

    def atl(self):
        """Wrapper around ask_to_list()."""
        self.ask_to_list()

    def l(self):
        """Wrapper around ask_to_list()."""
        self.ask_to_list()

    def hdyk(self):
        """Wrapper around how_do_you_know()."""
        self.how_do_you_know()

    def list(self):
        """Wrapper around ask_to_list()."""
        self.ask_to_list()

    def hinge(self, address_number=None):
        """Wrapper around talk_about_hinge()."""
        self.talk_about_hinge(address_number=address_number)

    def ap(self, addressee=None):
        """Wrapper around address()."""
        self.address(addressee=addressee)

    def ad(self, house_number=None):
        """Wrapper around approach()."""
        self.approach(house_number=house_number)


offline_mode = False
bn = Game(offline_mode=offline_mode)
g = bn.sim
pc = bn.player
d = bn.deceased_character
nok = bn.next_of_kin
uai = bn.communicator.update_actor_interface
upi = bn.communicator.update_player_interface
test = bn.communicator.test
begin = bn.begin