import sys
# TODO BEFORE GOING LIVE ADD ALL ANYTOWN FILES INTO THIS PROJECT DIRECTORY
PATH_TO_ANYTOWN = '../anytown'
sys.path.append(PATH_TO_ANYTOWN)

from game import Game as Sim
from conversation import *
from communicator import Communicator
import random
import string


REMOTE_WIZARD = True

# TODO LIST GRAVESTONES IN THE CEMETERY


NUMERAL_TO_WORD = {
    0: 'zero',
    1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five',
    6: 'six', 7: 'seven', 8: 'eight', 9: 'nine', 10: 'ten',
    11: 'eleven', 12: 'twelve', 13: 'thirteen', 14: 'fourteen',
    15: 'fifteen', 16: 'sixteen', 17: 'seventeen',
    18: 'eighteen', 19: 'nineteen', 20: 'twenty',
}


class Game(object):
    """A Bad News gameplay instance."""

    def __init__(self, offline_mode=False, remote_wizard=REMOTE_WIZARD):
        """Initialize a Game object."""
        if offline_mode:
            print "Okay. Preparing for single-player mode."
        self.sim = Sim()  # A city simulation generated by game.py
        try:
            self.sim.establish_setting()
        except KeyboardInterrupt:  # Allows game master to cut off worldgen early
            pass
        print "\nPreparing for gameplay..."
        self.sim.enact_no_fi_simulation()
        self.city = self.sim.city
        self.town = self.city
        self.offline_mode = offline_mode  # Whether James is playtesting, in which case don't show hidden knowledge
        self.remote_wizard = remote_wizard
        self.deceased_character = self._select_deceased_character()
        self.nok = self.next_of_kin = self._determine_all_valid_next_of_kin()
        self.player = Player(game=self)
        self.player.location = self.deceased_character.location
        # A communicator facilitates communication between the simulation and various game interfaces
        if offline_mode:
            self.communicator = None
        else:
            self.communicator = Communicator(game=self, remote_wizard=remote_wizard)
        self._simulate_the_death()
        self._init_set_up_helper_attributes()

    def _init_set_up_helper_attributes(self):
        """Set all helper attributes that pertain solely to this gameplay experience."""
        for person in self.city.residents | self.city.departed | self.city.deceased:
            person.temp_address_number = -1
            person.matches = [p for p in person.mind.mental_models if p.type == "person"]  # Matches to a mind query
            person.earlier_matches = []  # Allows going back to the last good set of matches after narrowing too far
            person.hinges = []  # Allows use of address numbers with hinges

    def _select_deceased_character(self):
        """Prepare the soon-to-be deceased character whose next-of-kin the
        player will be tasked with notifying.

        Currently, this method just randomly picks a person who has had an occupation at some
        point, has both friends and extended family in town, and is currently home alone.
        """
        potential_selections = [
            p for p in self.city.residents if p.location is p.home and
            len(p.location.people_here_now) == 1 and
            p.occupations and
            p.friends and
            p.greatgrandparents | p.grandparents | p.aunts | p.uncles | p.nieces | p.nephews | p.cousins
        ]
        deceased_character = max(potential_selections, key=lambda character: len(
            [r for r in self.city.residents if character in r.mind.mental_models]
        )
        )
        return deceased_character

    def _simulate_the_death(self):
        """Simulate the death of the deceased character without actually killing them."""
        # Don't actually kill the character, just remove them from the simulation
        # by removing them from the 'residents' attribute of the gameplay city;
        # if we kill the character, a bunch of issues arise
        self.city.residents.remove(self.deceased_character)
        # self.deceased_character.location.people_here_now.remove(self.deceased_character)
        self.deceased_character.alive = False  # Crucially we do not call .die() method here

    def _determine_all_valid_next_of_kin(self):
        """Determine all the characters in town who could be successfully notified as the next of kin."""
        # Spouse
        if self.deceased_character.spouse and self.deceased_character.spouse.present:
            return [self.deceased_character.spouse]
        # Parents
        if self.deceased_character.parents and any(p for p in self.deceased_character.parents if p.present):
            return [p for p in self.deceased_character.parents if p.present]
        # Kids
        if self.deceased_character.kids and any(k for k in self.deceased_character.kids if k.present):
            return [k for k in self.deceased_character.kids if k.present]
        # Siblings
        if self.deceased_character.siblings and any(s for s in self.deceased_character.siblings if s.present):
            return [s for s in self.deceased_character.siblings if s.present]
        # Extended family (greatgrandparents, grandparents, aunts, uncles, cousins, nieces, nephews)
        if self.deceased_character.extended_family and any(
                ef for ef in self.deceased_character.extended_family if ef.present
        ):
            return [ef for ef in self.deceased_character.extended_family if ef.present]

    def begin(self):
        """Prepare preliminary information and start rendering the player and actor interfaces."""
        self._display_preliminary_information()
        if not offline_mode:
            if not REMOTE_WIZARD:
                for _ in xrange(10):
                    self.communicator.update_player_interface()
            else:
                self.communicator.update_player_interface()
            self.communicator.update_actor_interface()

    def _display_preliminary_information(self):
        """Display preliminary information explaining the player interface."""
        self.communicator.current_logo_src = "bad_news_logo.png"
        self.communicator.current_logo_height = "102px"
        opening_prompt = (
            "This interface will be used to display information about your current environment as "
            "you move about the town; <b>it is not interactive</b>. To carry out an action, such as going outside "
            "or traveling to a given address, simply say what you'd like to do out loud. Your reference sheet has a "
            "list of actions that you can take."
            "<br><br>"
            "When you are ready to begin, say so out loud."
        )
        self.communicator.player_exposition = opening_prompt
        self.communicator.player_exposition_enumeration = ''

    def prompt(self):
        """Display the opening player exposition."""
        self._compose_opening_exposition()
        if not offline_mode:
            self.communicator.update_player_interface()
            self.communicator.update_actor_interface()

    def _compose_opening_exposition(self):
        """Render the initial exposition that opens the game."""
        self.communicator.current_logo_src = "bad_news_icon.png"
        self.communicator.current_logo_height = "72px"
        opening_exposition = (
            "It is {nighttime_or_daytime}, {date}. <b>You are in {a_house_or_apartment}</b> at {address} "
            "in the town of {city_name}, pop. {city_pop}. A deceased person lies before you. "
            "{pronoun} is {description}.<br><br>".format(
                nighttime_or_daytime='nighttime' if self.sim.time_of_day == 'night' else 'daytime',
                date=self.sim.date[7:] if self.sim.time_of_day == 'day' else self.sim.date[9:],
                a_house_or_apartment="a house" if self.player.location.house else "an apartment",
                address=self.player.location.address,
                city_name=self.city.name,
                city_pop=self.city.population,
                pronoun=self.deceased_character.subject_pronoun.capitalize(),
                description=self.deceased_character.description[:-11],  # Excise ' (deceased)' modifier
                possessive=self.deceased_character.possessive_pronoun
            )
        )
        if self.offline_mode:
            print '\n{}\n'.format(opening_exposition)
        else:
            # Set this now and it will display on the player interface when
            # 'begin()' is called -- otherwise, we could screw up the interface
            # of a game already in progress while this sim is being prepared
            self.communicator.player_exposition = opening_exposition
            self.communicator.player_exposition_enumeration = ''

    def advance_timestep(self):
        """Advance to the next timestep."""
        self.sim.enact_no_fi_simulation()

    def epilogue(self):
        """Simulate the game world until 2010."""
        # Actually model the death
        self.city.residents.add(self.deceased_character)
        self.deceased_character.alive = True
        self.deceased_character.die('Unknown circumstances')
        while self.sim.year < 2010:
            self.sim.enact_lo_fi_simulation(5)


class Player(object):
    """A collection of data and affordances surrounding a player's interaction with a Bad News game world."""

    def __init__(self, game):
        """Initialize a Player object."""
        self.game = game
        self.city = game.city
        self.location = None  # Gets set by game
        self.outside = False  # Since you start in the deceased character's home
        self.places_i_have_been = []
        self.people_i_know_by_name = set()
        self.houses_i_know_by_name = set()
        self.salient_person_who_lives_in_a_house = {}
        self.last_address_i_heard = None
        self.last_unit_number_i_heard = None
        self.last_block_i_heard = None
        self.interlocutor = None
        self.all_interlocutors = []  # Ordered list of all the NPCs player has talked to
        self.subject_of_conversation = None  # Character whom player and interlocutor are currently talking about
        self.current_list_index = 0  # Facilitates ask_to_list methods
        self.refrain = self._determine_initial_refrain()  # Features they keep asking about

    def _determine_initial_refrain(self):
        """Set the player's initial refrain to match the description of the deceased person."""
        deceased_character = self.game.deceased_character
        # Set age range
        if deceased_character.age < 1:
            features_str = 'ar=infant'
        elif deceased_character.age < 4:
            features_str = 'ar=toddler'
        elif deceased_character.age < 10:
            features_str = 'ar=young'
        elif deceased_character.age < 13:
            features_str = 'ar=preteen'
        elif deceased_character.age < 20:
            features_str = 'ar=teenage'
        elif deceased_character.age < 25:
            features_str = 'ar=young adult'
        elif deceased_character.age < 45:
            features_str = 'ar=adult'
        elif deceased_character.age < 65:
            features_str = 'ar=middle-aged'
        elif deceased_character.age < 75:
            features_str = 'ar=older'
        else:
            features_str = 'ar=elderly'
        # Set physical characteristics
        broader_skin_color = {
            'black': 'dark', 'brown': 'dark',
            'beige': 'light', 'pink': 'light',
            'white': 'light'
        }
        features_str += ',sc={}'.format(
            broader_skin_color[deceased_character.face.skin.color]
        )
        if deceased_character.face.distinctive_features.tattoo == 'yes':
            features_str += ',tattoo=yes'
        if deceased_character.face.distinctive_features.scar == 'yes':
            features_str += ',scar=yes'
        if deceased_character.face.distinctive_features.birthmark == 'yes':
            features_str += ',birthmark=yes'
        if deceased_character.face.distinctive_features.freckles == 'yes':
            features_str += ',freckles=yes'
        if deceased_character.face.distinctive_features.glasses == 'yes':
            features_str += ',glasses=yes'
        if deceased_character.face.hair.length == 'bald':
            features_str += ',hl=bald'
        else:
            features_str += ',hl={}'.format(deceased_character.face.hair.length)
            features_str += ',hc={}'.format(deceased_character.face.hair.color)
        if deceased_character.face.facial_hair.style == 'sideburns':
            features_str += ',fhsb=yes'
        elif deceased_character.face.facial_hair.style == 'goatee':
            features_str += ',fhg=yes'
        elif deceased_character.face.facial_hair.style == 'full beard':
            features_str += ',fhfb=yes'
        elif deceased_character.face.facial_hair.style == 'soul patch':
            features_str += ',fhsp=yes'
        elif deceased_character.face.facial_hair.style == 'mustache':
            features_str += ',fhm=yes'
        return features_str

    @property
    def buildings_on_this_block(self):
        """Return a ask_to_list of the buildings on the player's current block."""
        block = self.location if self.location.type == 'block' else self.location.block
        return [b for b in self.city.buildings if b.block is block]

    def goto(self, address=None, suppress_observation=False):
        """Move the player to a location with the given address.

        If no location exists at this address, move them simply to the associated block.
        """
        if self.location.type == 'block':
            lot_i_came_from = self.location.lots[0]
        else:
            lot_i_came_from = self.location.lot
        # Since this method is called when a player's location changes, it also
        # makes sense to end the character's current conversation, if any, because
        # usually this will co-occur with a command to move locations
        self.end_conversation()
        if not address:
            address = self.last_address_i_heard
        try:
            if ' (Unit' in address:
                address = address.split(' (Unit')[0]
            house_number = int(address[:3])
            street_object = self._find_street_object(address)
            self.location = next(
                b for b in self.city.buildings if b.house_number == house_number and
                b.block.street is street_object
            )
            self.outside = True
            self.places_i_have_been.append(self.location)
            lot_i_traveled_to = self.location.lot
            n_blocks_traveled = self.city.distance_between(lot_i_came_from, lot_i_traveled_to)
            distance_traveled = '{n} block{pl}'.format(
                n=NUMERAL_TO_WORD[n_blocks_traveled+1],
                pl='s' if n_blocks_traveled+1 != 1 else ''
            )
            if not suppress_observation:

                self.observe(distance_traveled=distance_traveled)
        except StopIteration:
            # Arrive then at that block
            house_number = int(address[:3])
            block_number = int(address[0] + '00')
            street_object = self._find_street_object(address)
            block_object = next(b for b in self.city.blocks if b.number == block_number and b.street is street_object)
            lot_i_traveled_to = self.location.lots[0]
            n_blocks_traveled = self.city.distance_between(lot_i_came_from, lot_i_traveled_to)
            distance_traveled = '{n} block{pl}'.format(
                n=NUMERAL_TO_WORD[n_blocks_traveled+1],
                pl='s' if n_blocks_traveled+1 != 1 else ''
            )
            if self.game.offline_mode:
                print "After traveling {} to the {}, you find no building with the house number {}.\n".format(
                    distance_traveled, block_object, house_number
                )
                exposition_prefix = None
            else:
                exposition_prefix = (
                    "After traveling {} to the {}, you find no building with the house number {}.".format(
                        distance_traveled, block_object, house_number
                    )
                )
            self.goto_block(block=block_object, exposition_prefix=exposition_prefix)

    def _find_street_object(self, address):
        """Complete a potentially abridged street name."""
        street_name = address[4:].lower()
        if street_name[-3:] == "ave":
            street_name += 'nue'
        elif street_name[-4:] == "ave.":
            street_name = street_name[:-1] + 'nue'
        elif street_name[-2:] == 'st':
            street_name += 'reet'
        elif street_name[-4:] == "st.":
            street_name = street_name[:-1] + 'reet'
        street_object = next(s for s in self.city.streets if s.name.lower() == street_name.lower())
        return street_object

    def go_downtown(self):
        """Go to the block where downtown is."""
        self.goto_block(block=self.city.downtown.block)

    def goto_block(self, block=None, exposition_prefix=None):
        """Move the character to the given block."""
        # Since this method is called when a player's location changes, it also
        # makes sense to end the character's current conversation, if any, because
        # usually this will co-occur with a command to move locations
        self.end_conversation()
        if not block:
            block = self.last_block_i_heard
        if type(block) == str:
            try:
                block = next(b for b in self.city.blocks if str(block) == b)
            except StopIteration:
                raise Exception('There is no {}'.format(block))
        self.location = block
        self.outside = True
        self.observe(exposition_prefix=exposition_prefix)

    def goto_co(self, business_name):
        """Go to the business in town with the given name."""
        business = next(c for c in self.city.companies if c.name == business_name)
        self.goto(business.address)

    def goto_nearest(self, business_type, that_i_havent_been_to=False):
        """Go to the nearest business of the given type."""
        businesses_of_that_type = self.city.businesses_of_type(business_type)
        if that_i_havent_been_to:
            businesses_of_that_type = list(set(businesses_of_that_type)-set(self.places_i_have_been))
        if businesses_of_that_type:
            if self.location.__class__.__name__ == 'Block':
                lot_i_am_on = random.choice(list(self.location.lots))
            else:
                lot_i_am_on = self.location.lot
            closest_business = min(
                businesses_of_that_type,
                key=lambda bar: self.city.distance_between(lot_i_am_on, bar.lot)
            )
            self.goto(closest_business.address)
        else:
            print "\nThere are no businesses of that type in {}.\n".format(
                self.city.name
            )

    def goto_bar(self):
        """Go to the closest bar in town."""
        self.goto_nearest('Bar')

    def goto_restaurant(self):
        """Go to the closest restaurant in town."""
        self.goto_nearest('Restaurant')

    def goto_school(self):
        """Go to the K-12 school in town."""
        self.goto(self.city.school.address)

    def goto_another(self, business_type):
        """Go to the nearest business of the given type that you haven't been to yet."""
        self.goto_nearest(business_type=business_type, that_i_havent_been_to=True)

    def go_back(self):
        """Go back to the last place you were at."""
        # Since this method is called when a player's location changes, it also
        # makes sense to end the character's current conversation, if any, because
        # usually this will co-occur with a command to move locations
        self.end_conversation()
        self.goto(self.places_i_have_been[-2].address)

    def go_knock(self, address):
        """A method that chains goto() and knock()."""
        self.goto(address=address, suppress_observation=True)
        self.game.communicator.player_exposition_enumeration = ''
        self.knock()

    def go_enter(self, address):
        """A method that chains goto() and enter()."""
        self.goto(address=address, suppress_observation=True)
        self.enter()

    def go_outside(self):
        """Go into the street and the observe the block you are on."""
        # Since this method is called when a player's location changes, it also
        # makes sense to end the character's current conversation, if any, because
        # usually this will co-occur with a command to move locations
        self.end_conversation()
        self.outside = True
        if self.location.__class__.__name__ == 'Apartment':
            self.location = self.location.complex  # Go outside to the intercom system
        else:
            self.location = self.location.block
        self.observe()

    def move(self, direction):
        """Move to an adjacent block."""
        # Since this method is called when a player's location changes, it also
        # makes sense to end the character's current conversation, if any, because
        # usually this will co-occur with a command to move locations
        self.end_conversation()
        if self.location.type != 'block':
            self.location = self.location.block
        try:
            direction = direction.lower()
        except AttributeError:  # int or something weird was passed as direction and will get caught anyway
            pass
        available_directions = ('n', 's') if self.location.street.direction in ('N', 'S') else ('e', 'w')
        if direction not in ('n', 'e', 's', 'w'):
            print "\nThat is not a valid direction. Please choose from among the following options: N, S, E, W.\n"
        elif direction not in available_directions:
            direction_to_name = {'w': 'west', 'e': 'east', 's': 'south', 'n': 'north'}
            print "\n{street_name} runs {direction1} to {direction2}.\n".format(
                street_name=self.location.street.name,
                direction1=direction_to_name[available_directions[0]],
                direction2=direction_to_name[available_directions[1]],
            )
        else:
            index_of_this_block_on_street = self.location.street.blocks.index(self.location)
            index_of_new_block = (
                index_of_this_block_on_street+1 if direction in ('n', 'e') else index_of_this_block_on_street-1
            )
            if index_of_new_block < 0 or index_of_new_block == len(self.location.street.blocks):
                direction_to_adj = {'w': 'western', 'e': 'eastern', 's': 'southern', 'n': 'northern'}
                print "\nYou are already at the {direction_adj} terminus of {street_name}.\n".format(
                    direction_adj=direction_to_adj[direction],
                    street_name=self.location.street.name
                )
            else:
                # Go to the new block
                new_block = self.location.street.blocks[index_of_new_block]
                self.goto_block(block=new_block)

    def approach(self, house_number=None):
        """Move the player to the building on her current block with the given house number."""
        if house_number < 100:
            print 'I think you meant to call address(), not approach().'
        elif not house_number:
            print "\nYou need to specify a house number to approach.\n"
        else:
            if self.location.__class__.__name__ != 'Block':
                self.location = self.location.block
            building_to_approach = None
            if len(self.location.buildings) == 1:
                building_to_approach = list(self.location.buildings)[0]
            else:
                try:
                    building_to_approach = next(b for b in self.location.buildings if b.house_number == house_number)
                except StopIteration:
                    print "\nThere is no building on this block with the house number {}\n".format(house_number)
            if building_to_approach:
                self.location = building_to_approach
                self.outside = True
                self.places_i_have_been.append(self.location)
                self.observe()

    def approach_apt(self, unit_number=None):
        """Move the player to the unit of the apartment she is currently outside with the given unit number."""
        if self.location.__class__.__name__ == "Apartment":
            self.location = self.location.complex
        if not unit_number:
            unit_number = self.last_unit_number_i_heard
        self.location = self.location.units[unit_number-1]
        self.outside = True  # Make sure elsewhere to check for outside + location being an apartment unit
        self.observe()

    def enter(self, house_number=None, let_in=False):
        """Enter a building."""
        if not house_number:
            # Then attempt to enter the building you are outside of
            if not self.location.locked or let_in or self.location is self.game.deceased_character.location:
                self.outside = False
                self.observe()
            else:
                exposition = 'The gate is locked.' if self.location.lot.tract else 'The door is locked.'
                if self.game.offline_mode:
                    print '\n{exposition}\n'.format(exposition=exposition)
                else:
                    self.game.communicator.player_exposition = exposition
                    if not REMOTE_WIZARD:
                        for _ in xrange(10):
                            self.game.communicator.update_player_interface()
                    else:
                        self.game.communicator.update_player_interface()
        else:
            if self.location.__class__.__name__ != 'Block':
                self.location = self.location.block
            building_to_approach = next(b for b in self.location.buildings if b.house_number == house_number)
            self.location = building_to_approach
            if not self.location.locked or let_in or self.location is self.game.deceased_character.location:
                self.outside = False
                self.observe()
            else:
                exposition = 'The gate is locked.' if self.location.lot.tract else 'The door is locked.'
                if self.game.offline_mode:
                    print '\n{exposition}\n'.format(exposition=exposition)
                else:
                    self.game.communicator.player_exposition = exposition
                    self.game.communicator.update_player_interface()

    def enter_apt(self, unit_number=None, let_in=False):
        """Enter a building."""
        if not unit_number:
            # Then attempt to enter the apartment unit you are standing outside of
            if not self.location.locked or let_in or self.location is self.game.deceased_character.location:
                self.outside = False
                self.observe()
            else:
                print 'The door is locked.'
        else:
            if self.location.__class__.__name__ != 'ApartmentComplex':
                self.location = self.location.complex
            apartment_unit_to_approach = next(a for a in self.location.units if a.unit_number == unit_number)
            self.location = apartment_unit_to_approach
            if not self.location.locked or let_in or self.location is self.game.deceased_character.location:
                self.outside = False
                self.observe()
            else:
                print 'The door is locked.'

    def exit(self):
        """Exit a building."""
        # Since this method is called when a player's location changes, it also
        # makes sense to end the character's current conversation, if any, because
        # usually this will co-occur with a command to move locations
        self.end_conversation()
        self.outside = True
        self.observe()

    def observe(self, exposition_prefix=None, update_enumeration_only=False, distance_traveled=None):
        """Describe the player's current setting."""
        if self.outside:  # Interior scenes
            if self.location.type == 'block':
                exposition, enumeration = self._describe_the_block_player_is_on(

                    distance_traveled=distance_traveled)
            elif self.location.__class__.__name__ == 'House':
                exposition = self._describe_house_exterior(
                    distance_traveled=distance_traveled
                )
                enumeration = ''
            elif self.location.__class__.__name__ == 'Apartment':
                exposition = self._describe_apartment_unit_exterior()
                enumeration = ''
            elif self.location.__class__.__name__ == 'ApartmentComplex':
                exposition, enumeration = self._describe_apartment_complex_exterior(
                    distance_traveled=distance_traveled
                )
            else:  # Business
                exposition = self._describe_business_exterior(
                    distance_traveled=distance_traveled
                )
                enumeration = ''
        else:  # Exterior scenes
            if self.location.type == 'residence':
                exposition, enumeration = self._describe_home_interior()
            else:
                exposition, enumeration = self._describe_business_interior()
        if self.game.offline_mode:
            if enumeration:
                exposition += '\n' + enumeration
            print "\n{}\n".format(exposition)
        else:
            # Update the player interface; sometimes an exposition prefix
            # may propagate up from other methods to this one -- this is just
            # some fragment of text that should precede the observational text
            if exposition_prefix:
                exposition = exposition_prefix + '<br><br>' + exposition
            exposition = exposition.replace('\n', '<br>')
            if not update_enumeration_only:
                # update_enumeration_only will be True when remember() calls this
                # method to update the enumeration to include an NPC's name
                self.game.communicator.player_exposition = exposition
            self.game.communicator.player_exposition_enumeration = enumeration
            if not REMOTE_WIZARD:
                for _ in xrange(10):
                    self.game.communicator.update_player_interface()
            else:
                self.game.communicator.update_player_interface()

    def _describe_the_block_player_is_on(self, distance_traveled=None):
        """Describe the block that the player is on."""
        buildings_on_this_block = [lot.building for lot in self.location.lots if lot.building]
        if buildings_on_this_block:
            buildings_enumeration = self._describe_buildings_on_block()
            if len(buildings_on_this_block) > 1:
                exposition = "{} the {}. There are {} buildings here:".format(
                    "You are at" if not distance_traveled else "You traveled {} to".format(
                        distance_traveled
                    ),
                    self.location,
                    NUMERAL_TO_WORD[len(buildings_on_this_block)],
                    buildings_enumeration
                )
            else:
                exposition = "{} the {}. There is one building here:".format(
                    "You are at" if not distance_traveled else "You traveled {} to".format(
                        distance_traveled
                    ),
                    self.location,
                    buildings_enumeration
                )
        else:
            exposition = "{} the {}. There are no buildings here.".format(
                "You are at" if not distance_traveled else "You traveled {} to".format(
                    distance_traveled
                ),
                self.location
            )
            buildings_enumeration = ''
        return exposition, buildings_enumeration

    def _describe_buildings_on_block(self):
        """Generate a pretty-printable description of buildings on the block the player is on."""
        line_prefix = '\n\t' if self.game.offline_mode else '<br><b>'
        tab = '\t' if self.game.offline_mode else '</b><br>'
        description = ""
        buildings_on_this_block = [lot.building for lot in self.location.lots if lot.building]
        for building in buildings_on_this_block:
            description += line_prefix
            if building.__class__.__name__ in ('Bar', 'Restaurant'):
                description += '{}{}A {} whose sign reads: "{}"'.format(
                    building.lot.house_number,
                    tab,
                    building.__class__.__name__.lower(), building.sign
                )
            elif building.__class__.__name__ == 'House':
                if self.game.sim.time_of_day == 'night':
                    lights_on = (
                        ' with its lights on' if
                        (building.people_here_now and building is not self.game.deceased_character.home)
                        else ' with its lights off'
                    )
                else:
                    lights_on = ''
                if building in self.houses_i_know_by_name:
                    lights_on = ','+lights_on if lights_on else ''
                    "{}{}{}'s house{}".format(
                        building.lot.house_number,
                        tab,
                        self.salient_person_who_lives_in_a_house[building].name,
                        lights_on
                    )
                else:
                    description += '{}{}A private residence{}'.format(
                        building.lot.house_number,
                        tab,
                        lights_on
                    )
            else:  # A business that's not a bar or restaurant
                if building.__class__.__name__ == 'Farm':
                    description += '{house_number}{tab}A farm'.format(
                        house_number=building.house_number,
                        tab=tab,
                    )
                else:
                    description += '{house_number}{tab}A {gated_area_or_company} whose sign reads: "{sign}"'.format(
                        house_number=building.lot.house_number,
                        tab=tab,
                        gated_area_or_company='gated area' if building.lot.tract else 'company',
                        sign=building.sign
                    )
        return description

    def _describe_house_exterior(self, distance_traveled=None):
        """Describe the house whose doorstep the player is standing on."""
        if self.location in self.houses_i_know_by_name:
            whose_house = "{person_i_know_lives_here}'s house".format(
                person_i_know_lives_here=self.salient_person_who_lives_in_a_house[self.location].name
            )
        else:
            whose_house = "a house"
        if len(self.location.people_here_now) > 3:
            noise_of_activity_inside = "a bustle of activity inside"
        elif self.location.people_here_now:
            noise_of_activity_inside = "a faint noise inside"
        else:
            noise_of_activity_inside = "nothing inside"
        if self.location is self.game.deceased_character.location:
            # Special exposition if it's the deceased character's house
            exposition = (
                "{intro} the doorstep of the deceased person's house at {address}. "
                "{lights_segment_if_night}ts door is unlocked, and you hear nothing inside.".format(
                    intro="You are at" if not distance_traveled else "You traveled {} to".format(
                        distance_traveled
                    ),
                    address=self.location.address,
                    lights_segment_if_night="Its lights are off, i" if self.game.sim.time_of_day == 'night' else 'I',
                )
            )
        elif self.game.sim.time_of_day == "night":
            exposition = (
                "{intro} the doorstep of {whose_house} at {address}. "
                "Its lights are {lights_on}, its door is {door_locked}, and you hear {noise_of_activity_inside}.".format(
                    intro="You are at" if not distance_traveled else "You traveled {} to".format(
                        distance_traveled
                    ),
                    whose_house=whose_house,
                    address=self.location.address,
                    lights_on="on" if self.location.people_here_now else "off",
                    door_locked="locked" if self.location.locked else "unlocked",
                    noise_of_activity_inside=noise_of_activity_inside
                )
            )
        else:
            exposition = (
                "{intro} the doorstep of {whose_house} at {address}. "
                "Its door is {door_locked} and you hear {noise_of_activity_inside}.".format(
                    intro="You are at" if not distance_traveled else "You traveled {} to".format(
                        distance_traveled
                    ),
                    whose_house=whose_house,
                    address=self.location.address,
                    door_locked="locked" if self.location.locked else "unlocked",
                    noise_of_activity_inside=noise_of_activity_inside
                )
            )
        return exposition

    def _describe_apartment_unit_exterior(self):
        """Describe the apartment unit whose door the player is standing at."""
        if self.location in self.houses_i_know_by_name:
            whose_apartment = "{person_i_know_lives_here}'s apartment, unit #{unit_number}".format(
                person_i_know_lives_here=self.salient_person_who_lives_in_a_house[self.location].name,
                unit_number=self.location.unit_number
            )
        elif self.location is self.game.deceased_character.location:
            whose_apartment = "the deceased person's apartment, unit #{unit_number}".format(
                unit_number=self.location.unit_number
            )
        else:
            whose_apartment = "unit #{unit_number}".format(unit_number=self.location.unit_number)
        if len(self.location.people_here_now) > 3:
            noise_of_activity_inside = "a bustle of activity inside"
        elif self.location.people_here_now:
            noise_of_activity_inside = "a faint noise inside"
        else:
            noise_of_activity_inside = "nothing"
        if self.location.locked and self.location.people_here_now:
            conjunction = ', but'
        else:
            conjunction = ' and'
        if self.location is self.game.deceased_character.location:
            # Special exposition if it's the deceased character's house
            exposition = (
                "You are in a hallway standing outside {whose_apartment} of {apartment_complex}. "
                "Its door is unlocked and you hear nothing inside.".format(
                    whose_apartment=whose_apartment,
                    apartment_complex=self.location.complex.name,
                )
            )
        else:
            exposition = (
                "You are in a hallway standing outside the door of {whose_apartment} of {apartment_complex}. "
                "Its door is {door_locked}{conjunction} you hear {noise_of_activity_inside}.".format(
                    whose_apartment=whose_apartment,
                    apartment_complex=self.location.complex.name,
                    door_locked="locked" if self.location.locked else "unlocked",
                    conjunction=conjunction,
                    noise_of_activity_inside=noise_of_activity_inside
                )
            )
        return exposition

    def _describe_apartment_complex_exterior(self, distance_traveled=None):
        """Describe the apartment complex, particularly its intercom system, that the player is outside of."""
        try:
            janitor_in_lobby = next(e for e in self.location.working_right_now if e[0] == 'janitor')
        except StopIteration:
            janitor_in_lobby = None
        if janitor_in_lobby:
            lobby_str = ", but there is a janitor in the lobby"
        else:
            lobby_str = " and the lobby is empty"
        exposition = (
            "{intro} the entrance of {complex_name} at {address}. Its entrance is locked{lobby_str}. There "
            "are {n_options} options listed on the intercom system:".format(
                intro="You are at" if not distance_traveled else "You traveled {} to".format(
                    distance_traveled
                ),
                complex_name=self.location.name,
                address=self.location.address,
                lobby_str=lobby_str,
                n_options=len(self.location.units)+1,
            )
        )
        enumeration = self._describe_apartment_complex_intercom()
        return exposition, enumeration

    def _describe_apartment_complex_intercom(self):
        """Describe the apartment complex's intercom system, listing units and names."""
        line_prefix = '\n\t' if self.game.offline_mode else '<br><b>'
        tab = '\t' if self.game.offline_mode else '</b><br>'
        intercom_description = ""
        for unit in self.location.units:
            if unit.owners:
                all_surnames_among_owners = {owner.last_name for owner in unit.owners}
                owner_str = '/'.join(all_surnames_among_owners)
            else:
                owner_str = '--'
            intercom_description += '{line_prefix}#{unit_no}{tab}{owners_surnames}'.format(
                line_prefix=line_prefix,
                unit_no=unit.unit_number,
                tab=tab,
                owners_surnames=owner_str
            )
        intercom_description += "\n{line_prefix}#99{tab}Office".format(
            line_prefix=line_prefix,
            tab=tab
        )
        return intercom_description

    def view_business_directory(self):
        """View the city's business directory, which is a listing of businesses and their addresses."""
        self.game.communicator.player_exposition = (
            "You are viewing the {city_name} business directory.".format(
                city_name=self.game.city.name
            )
        )
        self.game.communicator.player_exposition_enumeration = self._compile_city_business_directory()
        if not REMOTE_WIZARD:
            for _ in xrange(10):
                self.game.communicator.update_player_interface()
        else:
            self.game.communicator.update_player_interface()

    def _compile_city_business_directory(self):
        """Compile the city's business directory, which is a listing of businesses and their addresses."""
        line_prefix = '\n\t' if self.game.offline_mode else '<br><b>'
        tab = '\t' if self.game.offline_mode else '</b><br>'
        business_directory = ""
        for business in sorted(self.city.companies, key=lambda c: c.name):
            business_directory += '{line_prefix}{business_name}{tab}{address}'.format(
                line_prefix=line_prefix,
                business_name=business.name,
                tab=tab,
                address=business.address,
            )
        return business_directory

    def view_residential_directory(self):
        """View the city's residential directory, which is a listing of residents and their addresses."""
        self.game.communicator.player_exposition = (
            "You are viewing the {city_name} residential directory.".format(
                city_name=self.game.city.name
            )
        )
        self.game.communicator.player_exposition_enumeration = self._compile_city_residential_directory()
        if not REMOTE_WIZARD:
            for _ in xrange(10):
                self.game.communicator.update_player_interface()
        else:
            self.game.communicator.update_player_interface()

    def _compile_city_residential_directory(self):
        """Compile the city's residential directory, which is a listing of residents and their addresses."""
        line_prefix = '\n\t' if self.game.offline_mode else '<br><b>'
        tab = '\t' if self.game.offline_mode else '</b><br>'
        residential_directory = ""
        for home in sorted(self.city.dwelling_places, key=lambda c: c.name):
            if home.residents:
                residential_directory += '{line_prefix}{residence_name}{tab}{address}'.format(
                    line_prefix=line_prefix,
                    residence_name=home.name[:-10],  # Excise ' residence', which is redundant here
                    tab=tab,
                    address=home.address,
                )
        return residential_directory

    def _describe_business_exterior(self, distance_traveled=None):
        """Describe the business a player is outside of."""
        if len(self.location.people_here_now) > 8:
            n_people_inside = "many people"
        elif len(self.location.people_here_now) > 4:
            n_people_inside = "several people"
        elif len(self.location.people_here_now) > 1:
            n_people_inside = "a few people"
        elif self.location.people_here_now:
            # A single person -- if it's a janitor, be more specific and
            # explicitly say that
            if self.location.working_right_now and self.location.working_right_now[0][0] == 'janitor':
                n_people_inside = "a janitor"
            else:
                n_people_inside = "a person"
        else:
            n_people_inside = "no one"
        if self.location.locked and self.location.people_here_now:
            conjunction = ', but'
        else:
            conjunction = ' and'
        exposition = (
            "{intro} the entrance of {business_name} at {address}. "
            "Its {gate_or_door} is {door_locked}{conjunction} you see {n_people_inside} "
            "{inside_or_on_premises}.".format(
                intro="You are at" if not distance_traveled else "You traveled {} to".format(
                    distance_traveled
                ),
                business_name=self.location.name if self.location.__class__.__name__ != 'Farm' else 'a farm',
                address=self.location.address,
                gate_or_door="gate" if self.location.lot.tract else "door",
                door_locked="locked" if self.location.locked else "unlocked",
                conjunction=conjunction,
                n_people_inside=n_people_inside,
                inside_or_on_premises="on the premises" if self.location.lot.tract else "inside"
            )
        )
        return exposition

    def _describe_home_interior(self):
        """Describe the interior of a house that the player is in."""
        if self.location in self.houses_i_know_by_name:
            house_noun_phrase = "the {house_or_apartment} of {person_i_know_lives_here}".format(
                house_or_apartment="home" if self.location.house else "apartment",
                person_i_know_lives_here=self.salient_person_who_lives_in_a_house[self.location].name
            )
        else:
            house_noun_phrase = "{house_or_apartment}".format(
                house_or_apartment="a home" if self.location.house else "an apartment"
            )
        if self.location is self.game.deceased_character.location:
            people_here_intro = "The deceased person remains here:"
        elif len(self.location.people_here_now) > 14:
            people_here_intro = "There are many people here:".format(
                len(self.location.people_here_now)
            )
        elif len(self.location.people_here_now) > 7:
            people_here_intro = "There are several people here:"
        elif len(self.location.people_here_now) > 1:
            people_here_intro = "There are {number_word} people here:".format(
                number_word=NUMERAL_TO_WORD[len(self.location.people_here_now)]
            )
        elif self.location.people_here_now:
            people_here_intro = "There is a single person here:"
        else:
            people_here_intro = "There is no one here."
        exposition = (
            "You are inside {house_noun_phrase} at {address}. "
            "{people_here_intro}".format(
                house_noun_phrase=house_noun_phrase,
                address=self.location.address,
                people_here_intro=people_here_intro
            )
        )
        enumeration = self._describe_people_in_home()
        return exposition, enumeration

    def _describe_people_in_home(self):
        """Describe the individuals currently situated in a residence that the player is in."""
        line_prefix = '\n\t' if self.game.offline_mode else '<br><b>'
        tab = '\t' if self.game.offline_mode else '</b><br>'
        people_present_description = ""
        people_here_now = list(self.location.people_here_now)
        if self.location is self.game.deceased_character.location:
            people_here_now = [self.game.deceased_character]
        for i in xrange(len(people_here_now)):
            person = people_here_now[i]
            person.temp_address_number = i
            if person in self.people_i_know_by_name:
                people_present_description += '{line_prefix}{i}{tab}{persons_name}'.format(
                    line_prefix=line_prefix,
                    i=person.temp_address_number,
                    tab=tab,
                    persons_name=person.name
                )
            else:
                people_present_description += '{line_prefix}{i}{tab}{age_gender} with {appearance}'.format(
                    line_prefix=line_prefix,
                    i=person.temp_address_number,
                    tab=tab,
                    age_gender=person.age_and_gender_description,
                    appearance=person.basic_appearance_description
                ).capitalize()
        return people_present_description

    def _describe_business_interior(self):
        """Describe the interior of a business that the player is in."""
        if len(self.location.people_here_now) > 14:
            people_here_intro = "There are many people here:".format(
                len(self.location.people_here_now)
            )
        elif len(self.location.people_here_now) > 7:
            people_here_intro = "There are several people here:"
        elif len(self.location.people_here_now) > 1:
            people_here_intro = "There are {number_word} people here:".format(
                number_word=NUMERAL_TO_WORD[len(self.location.people_here_now)]
            )
        elif self.location.people_here_now:
            people_here_intro = "There is a single person here:"
        else:
            people_here_intro = "There is no one here."
        exposition = (
            "You are {inside_or_on_premises_of} {business_name} at {address}. "
            "{people_here_intro}".format(
                inside_or_on_premises_of='on the premises of' if self.location.lot.tract else 'inside',
                business_name=self.location.name if self.location.__class__.__name__ != 'Farm' else 'a farm',
                address=self.location.address,
                people_here_intro=people_here_intro
            )
        )
        enumeration = self._describe_people_in_business()
        return exposition, enumeration

    def _describe_people_in_business(self):
        """Describe the individuals currently situated in a residence that the player is in."""
        line_prefix = '\n\t' if self.game.offline_mode else '<br><b>'
        tab = '\t' if self.game.offline_mode else '</b><br>'
        people_present_description = ""
        people_here_now = list(self.location.people_here_now)
        # List people working here first (sorted by job level)
        people_here_now.sort(
            key=lambda p: (p.routine.working,
                           0 if not p.occupation or not p.routine.working else p.occupation.level),
            reverse=True
        )
        for i in xrange(len(people_here_now)):
            person = people_here_now[i]
            person.temp_address_number = i
            if (self.game.sim.time_of_day == 'day' and self.location.__class__.__name__ == 'School' and
                    person.whereabouts.date[(self.game.sim.ordinal_date, 0)].occasion == 'school'):
                occupation_if_working = ' (student)'
            else:
                occupation_if_working = ' ({})'.format(person.occupation.vocation) if person.routine.working else ''
            if person in self.people_i_know_by_name:
                people_present_description += '{line_prefix}{i}{tab}{persons_name}{occupation_if_working}'.format(
                    line_prefix=line_prefix,
                    i=person.temp_address_number,
                    tab=tab,
                    persons_name=person.name,
                    occupation_if_working=occupation_if_working

                )
            else:
                people_present_description += (
                    '{line_prefix}{i}{tab}{age_gender} with {appearance}{occupation_if_working}'.format(
                        line_prefix=line_prefix,
                        i=person.temp_address_number,
                        tab=tab,
                        age_gender=person.age_and_gender_description,
                        appearance=person.basic_appearance_description,
                        occupation_if_working=occupation_if_working
                    ).capitalize()
                )
        return people_present_description

    def address(self, addressee=None):
        """Address person with the given name here, or else the only person here."""
        if addressee is not None:
            if type(addressee) == str:
                name = addressee
                address_number = None
            else:
                address_number = addressee
                name = None
        else:
            name = None
            address_number = None
        if self.location.people_here_now:
            if len(self.location.people_here_now) == 1:
                new_interlocutor = list(self.location.people_here_now)[0]
                self.change_interlocutor(new_interlocutor=new_interlocutor)
                exposition = "You are about to speak to {age_and_gender_nominal} with {appearance} [{i}]. {nearby}".format(
                    age_and_gender_nominal=self.interlocutor.age_and_gender_description,
                    appearance=self.interlocutor.basic_appearance_description,
                    i='<b>{}</b>'.format(self.interlocutor.temp_address_number),
                    nearby="The following people are still nearby:" if not self.game.offline_mode else ''
                )
            else:
                if any(p for p in self.location.people_here_now if p.name == name):
                    new_interlocutor = next(p for p in self.location.people_here_now if p.name == name)
                    self.change_interlocutor(new_interlocutor=new_interlocutor)
                    exposition = "You are about to speak to {age_and_gender_nominal} with {appearance} [{i}]. {nearby}".format(
                        age_and_gender_nominal=self.interlocutor.age_and_gender_description,
                        appearance=self.interlocutor.basic_appearance_description,
                        i='<b>{}</b>'.format(self.interlocutor.temp_address_number),
                        nearby="The following people are still nearby:" if not self.game.offline_mode else ''
                    )
                elif any(p for p in self.location.people_here_now if p.temp_address_number == address_number):
                    new_interlocutor = next(
                        p for p in self.location.people_here_now if p.temp_address_number == address_number
                    )
                    self.change_interlocutor(new_interlocutor=new_interlocutor)
                    exposition = "You are about to speak to {age_and_gender_nominal} with {appearance} [{i}]. {nearby}".format(
                        age_and_gender_nominal=self.interlocutor.age_and_gender_description,
                        appearance=self.interlocutor.basic_appearance_description,
                        i='<b>{}</b>'.format(self.interlocutor.temp_address_number),
                        nearby="The following people are still nearby:" if not self.game.offline_mode else ''
                    )
                else:
                    exposition = "I'm not sure whom you met.".format(name)
        else:
            exposition = 'No one is here.'.format(name)
        if self.game.offline_mode:
            print '\n{exposition}\n'.format(exposition=exposition)
        else:
            self.game.communicator.player_exposition = exposition
            if not REMOTE_WIZARD:
                for _ in xrange(10):
                    self.game.communicator.update_player_interface()
            else:
                self.game.communicator.update_player_interface()

    def change_interlocutor(self, new_interlocutor):
        """Change the current interlocutor, which will clear old information from the actor interface."""
        self.interlocutor = new_interlocutor
        self.all_interlocutors.append(self.interlocutor)
        self.game.communicator.matches_overview = ''
        self.game.communicator.matches_listing = ''
        self.game.communicator.set_sources_of_interlocutor_beliefs_about_subject()
        self.game.communicator.update_actor_interface()

    def end_conversation(self):
        """Set the interlocutor back to None and update the actor interface accordingly."""
        if self.interlocutor:
            self.interlocutor = None
            self.game.communicator.interlocutor_source_distribution = []
            self.game.communicator.matches_overview = ''
            self.game.communicator.matches_listing = ''
            self.game.communicator.update_actor_interface()

    def do_you_know(self, features_str=None, narrow=False):
        """Return a ask_to_list of all the mental models interlocutor has that match the given features.

        Features should be a ask_to_list of tuples, where the first element of each tuple is a feature
        type and the second element is the corresponding feature value, e.g., ('hair color',
        'brown') or ('first name', 'Paul').
        """
        if not features_str:
            features_str = self.refrain
        else:
            self.refrain = features_str
        features = self._parse_feature_strings(features_str)
        # Build a lambda function that we will use to build a list of
        # all the people in interlocutor's mind that match the given features
        matches_description = (
            lambda mental_model: all(
                str(mental_model.get_facet_to_this_belief_of_type(feature[0])) == feature[1]
                for feature in features if feature
            )
        )
        pool_searching_in = self.interlocutor.mind.mental_models if not narrow else self.interlocutor.matches
        self.interlocutor.earlier_matches = list(self.interlocutor.matches)
        self.interlocutor.matches = [
            p for p in pool_searching_in if
            p.type == "person" and
            matches_description(self.interlocutor.mind.mental_models[p])
        ]
        self.express_matches()

    @staticmethod
    def _parse_feature_strings(features_str):
        """Parse a set of feature strings to return a tuple of (feature_name, feature_value) tuples."""
        # First, try to parse as if a name was passed -- this is hacky, but allows a
        # nicely idiomatic default usage of do_you_know(name) while still allowing
        # the more general usage that I specify in the docstring
        if '=' not in features_str:
            first_name, last_name = features_str.split()
            features_list = [('first name', first_name), ('last name', last_name)]
            return features_list
        else:
            features_str = features_str.replace(' ', '')  # Remove whitespace
            features_str = features_str.replace('_', ' ')  # Automatically fix underscore mistakes
            features = features_str.split(',')  # Split on commas
            # Otherwise, parse all the features specified in the feature strings
            feature_name_expansions = {
                's': 'sex', 'hc': 'hair color', 'hl': 'hair length', 'f': 'freckles', 'b': 'birthmark',
                't': 'tattoo', 'g': 'glasses', 'fhs': 'sideburns', 'fhsb': 'sideburns', 'fhg': 'goatee',
                'fhfb': 'full beard', 'fhsp': 'soul patch', 'fhm': 'mustache', 'sc': 'broad skin color',
                'ar': 'age range', 'gl': 'glasses', 'fn': 'first name', 'ln': 'last name',
                'mn': 'middle name'
            }
            feature_value_expansions = {
                'bla': 'black', 'br': 'brown', 'bro': 'brown', 'blo': 'blonde', 'ma': 'middle-aged',
                'y': 'yes', 'n': 'no',  'm': 'male', 'f': 'female', 'l': 'long', 'md': 'medium',
                's': 'short', 'b': 'bald', 'e': 'elderly', 'o': 'older', 'i': 'infant', 't': 'toddler',
                'g': 'gray', 'w': 'white', 'r': 'red', 'ya': 'young adult'
            }
            features_list = []
            for feature in features:
                feature_name, feature_value = feature.lower().split('=')
                # Expand abbreviated tags
                if feature_name in feature_name_expansions:
                    feature_name = feature_name_expansions[feature_name]
                if feature_value in feature_value_expansions:
                    feature_value = feature_value_expansions[feature_value]
                # Fix common mistakes
                if feature_name == 'hair length' and feature_value == 'male':
                    feature_value = 'medium'
                elif feature_name == 'age range' and feature_value == 'male':
                    feature_value = 'middle-aged'
                elif feature_name == 'age range' and feature_value == 'yes':
                    feature_value = 'young'
                # Throw an error for detected mistakes that can't be automatically fixed
                if feature_name == 'hair color' and feature_value in ('bald', 'bl'):
                    raise Exception("You used the wrong abbreviation for the 'hair color' feature!")
                features_list.append((feature_name, feature_value))
            return features_list

    def express_matches(self):
        """Express the number matches interlocutor found from the mind query."""
        # If a single match was found, automatically make them the new subject of conversation;
        # further, if that person is at this very location right now, make that known to the actor
        if len(self.interlocutor.matches) == 1:
            if self.interlocutor.matches[0].location is self.location:
                if self.interlocutor.matches[0] is self.interlocutor:
                    and_they_are_right_here = " (and {pronoun} is me!)".format(
                        pronoun=self.interlocutor.matches[0].pronoun
                    )
                else:
                    and_they_are_right_here = " (and {pronoun} is here right now)".format(
                        pronoun=self.interlocutor.matches[0].pronoun
                    )
            else:
                and_they_are_right_here = ''
            matches_str = "Found a match{and_they_are_right_here}.".format(
                and_they_are_right_here=and_they_are_right_here
            )
            print '\n{matches_str}\n'.format(matches_str=matches_str)
            self.game.communicator.matches_overview = matches_str
            self.interlocutor.matches[0].temp_address_number = 999
            self.talk_about(subject_reference=999)
        else:
            matches_str = "Found {} matches.".format(len(self.interlocutor.matches))
            print '\n{matches_str}\n'.format(matches_str=matches_str)
            self.game.communicator.matches_overview = matches_str

    def narrow(self, features_str):
        """Narrow the matches interlocutor has found by specifying additional features."""
        assert self.interlocutor.matches != [], "Cannot narrow an empty list."
        self.refrain += ', ' + features_str
        self.do_you_know(features_str, narrow=True)

    def pop_back(self):
        """Pop back to the last good set of matches after narrowing too far."""
        self.interlocutor.matches = list(self.interlocutor.earlier_matches)
        self.express_matches()

    def ask_to_list(self, start_index=0, n_to_list=None):
        """Ask interlocutor to ask_to_list their potential matches to the player's question."""
        if not n_to_list:
            n_to_list = len(self.interlocutor.matches)
        self.game.communicator.matches_listing = ''
        print '\n'
        for i in xrange(start_index, start_index+n_to_list):
            match = self.interlocutor.matches[i]
            match.temp_address_number = i
            print "\t{i}\t{basic_description}".format(
                i=i,
                basic_description=self.interlocutor.mind.mental_models[match].basic_description
            )
            self.current_list_index = i
            self.game.communicator.matches_listing += '{line_break}{nok_marker}{basic_description}'.format(
                line_break='<br>' if i > 0 else '',
                nok_marker='!' if match in self.game.next_of_kin else '',
                basic_description=self.interlocutor.mind.mental_models[match].basic_description
            )
        print '\n'

    def list_a_few(self):
        """Ask interlocutor to list a few of their potential matches to the player's question."""
        self.ask_to_list(start_index=0, n_to_list=5)

    def list_a_few_more(self):
        """Ask interlocutor to list a few more of their potential matches to the player's question."""
        self.ask_to_list(start_index=self.current_list_index, n_to_list=5)

    def talk_about(self, subject_reference=None):
        """Change the subject of conversation to the person with the given address number."""
        # If a name of a person was passed, this works as a wrapper around do_you_know() that
        # is probably more intuitive to call in the heat of the moment
        if type(subject_reference) == str:
            self.do_you_know(subject_reference)
        else:
            # If a person object was passed, just make them the subject of conversation
            if type(subject_reference).__name__ in ('Person', 'PersonExNihilo'):
                self.subject_of_conversation = subject_reference
                self.game.communicator.set_sources_of_interlocutor_beliefs_about_subject()
            else:
                # A temp address number was passed, i.e., the conventional usage of this method
                self.subject_of_conversation = next(
                    p for p in self.interlocutor.matches if p.temp_address_number == subject_reference
                )
                self.game.communicator.set_sources_of_interlocutor_beliefs_about_subject()
            if not self.game.offline_mode:
                self.game.communicator.update_actor_interface()
                # self.interlocutor.mind.mental_models[self.subject_of_conversation].outline()
            if self.interlocutor.mind.mental_models[self.subject_of_conversation].relations_to_me:
                self.interlocutor.hinges = [
                    self.interlocutor.mind.mental_models[self.subject_of_conversation].relations_to_me[0][1]
                ]
            else:
                self.interlocutor.hinges = []

    def talk_about_hinge(self, address_number=None):
        """Change the subject of conversation to the hinge between interlocutor and the current subject."""
        if address_number is None:
            self.subject_of_conversation = self.interlocutor.hinges[0]
            self.game.communicator.set_sources_of_interlocutor_beliefs_about_subject()
        else:
            self.subject_of_conversation = next(
                p for p in self.interlocutor.hinges if p.temp_address_number == address_number
            )
            self.game.communicator.set_sources_of_interlocutor_beliefs_about_subject()
        if not self.game.offline_mode:
            self.game.communicator.update_actor_interface()
            # self.interlocutor.mind.mental_models[self.subject_of_conversation].outline()
        if self.interlocutor.mind.mental_models[self.subject_of_conversation].relations_to_me:
            self.interlocutor.hinges = [
                self.interlocutor.mind.mental_models[self.subject_of_conversation].relations_to_me[0][1]
            ]
        else:
            self.interlocutor.hinges = []

    def how_do_you_know(self):
        """List data about interlocutor's relationship with subject, including all of subject's
        relations to interlocutor, which also facilitates setting a hinge as the new subject of conversation.
        """
        self.interlocutor.hinges = []
        print "\n"
        if self.subject_of_conversation in self.interlocutor.relationships:
            print self.interlocutor.relationships[self.subject_of_conversation].outline()
        else:
            print "Type: None"
        print '\nRelations:\n'
        temp_address_number = 0
        for relation, hinge in self.interlocutor.mind.mental_models[self.subject_of_conversation].relations_to_me:
            if hinge:
                self.interlocutor.hinges.append(hinge)
                hinge.temp_address_number = temp_address_number
            print '{temp_address_number}\t{relation}'.format(
                temp_address_number=temp_address_number if hinge else '',
                relation=relation
            )
            if hinge:
                temp_address_number += 1
        print '\n'

    def who_lives_in(self, house_or_unit_number=None):
        """Ask interlocutor if they know who lives in a neighboring home with the given house_or_unit_number."""
        # Pre-narrow the interlocutor's matches to all the people that live nearby them
        # currently (i.e., exclude former neighbors who died)
        self.interlocutor.earlier_matches = list(self.interlocutor.matches)
        self.interlocutor.matches = [
            p for p in self.interlocutor.mind.mental_models if p.type == 'person' and
            p.alive and
            p in self.interlocutor.neighbors
        ]
        if house_or_unit_number:  # Having default be None facilitates wrapper calls from who_lives_by_you()
            if house_or_unit_number > 99:  # Must be house number
                self.interlocutor.matches = [
                    p for p in self.interlocutor.matches if p.home.house and
                    p.home.house_number == house_or_unit_number
                ]
            else:  # Must be unit number
                self.interlocutor.matches = [
                    p for p in self.interlocutor.matches if p.home.apartment and
                    p.home.unit_number == house_or_unit_number
                ]
        self.express_matches()

    def who_lives_here(self):
        """Wrapper around who_lives_in() that queries about the player's current location."""
        if self.location.apartment:
            current_house_or_unit_number = self.location.unit_number
        else:
            current_house_or_unit_number = self.location.house_number
        self.who_lives_in(house_or_unit_number=current_house_or_unit_number)

    def who_lives_by_you(self):
        """Ask interlocutor if they know their neighbors."""
        self.who_lives_in(house_or_unit_number=None)

    def ask_about(self, feature_type):
        """Ask about the given feature of the current subject of conversation."""
        mental_model = self.interlocutor.mind.mental_models[self.subject_of_conversation]
        facet = mental_model.get_facet_to_this_belief_of_type(feature_type=feature_type)
        print '\n{feature_value} ({confidence})\n'.format(
            feature_value=facet if facet else '[forgot]' if facet == '' else '?',
            confidence='-' if not facet else facet.strength_str
        )

    def remember(self):
        """Remember the name of the person you are talking to."""
        self.people_i_know_by_name.add(self.interlocutor)
        self.observe(exposition_prefix=None, update_enumeration_only=True)
        speak("You are speaking to {}.".format(pc.i.name))

    def ring(self):
        """Print exposition surrounding the ringing of a doorbell."""
        answerer = self._determine_who_answers_buzzer_or_doorbell(dwelling_place=self.location)
        if answerer is self.game.deceased_character:
            answerer = None
        if answerer:
            self.change_interlocutor(new_interlocutor=answerer)
        verb_phrase = 'comes to the gate' if self.location.lot.tract else 'answers the door'
        if answerer in self.people_i_know_by_name:
            exposition = '{answerer_name} {answers}.'.format(
                answerer_name=answerer.name,
                answers=verb_phrase
            )
        elif answerer:
            exposition = '{age_and_gender} with {appearance} {answers}.'.format(
                age_and_gender=answerer.age_and_gender_description.capitalize(),
                appearance=answerer.basic_appearance_description,
                answers=verb_phrase
            ).capitalize()
        else:
            exposition = 'No one {answers}.'.format(
                answers=verb_phrase
            )
        if self.game.offline_mode:
            print '\n{exposition}\n'.format(exposition=exposition)
        else:
            self.game.communicator.player_exposition = exposition
            if not REMOTE_WIZARD:
                for _ in xrange(10):
                    self.game.communicator.update_player_interface()
            else:
                self.game.communicator.update_player_interface()

    def knock(self):
        """Print exposition surrounding the knocking of a house's door."""
        self.ring()

    def buzz(self, unit_number):
        """Print exposition surrounding the buzzing of an apartment unit."""
        self.last_unit_number_i_heard = unit_number
        if unit_number == 99:
            answerer = self._buzz_apartment_complex_office()
        else:
            apartment_unit_buzzed = self.location.units[unit_number-1]
            answerer = self._determine_who_answers_buzzer_or_doorbell(
                dwelling_place=apartment_unit_buzzed
            )
        if answerer is self.game.deceased_character:
            answerer = None
        if answerer:
            self.change_interlocutor(new_interlocutor=answerer)
            exposition = 'You have buzzed Unit #{}. {} speaks into the intercom.'.format(
                unit_number, answerer.age_and_gender_description.capitalize()
            )
        else:
            self.interlocutor = None
            exposition = 'You have buzzed Unit #{}. No one answers.'.format(unit_number)
        if self.game.offline_mode:
            print '\n{exposition}\n'.format(exposition=exposition)
        else:
            self.game.communicator.player_exposition = exposition + ' The intercom system remains before you:'
            if not REMOTE_WIZARD:
                for _ in xrange(10):
                    self.game.communicator.update_player_interface()
            else:
                self.game.communicator.update_player_interface()

    def _buzz_apartment_complex_office(self):
        """Buzz the office of an apartment complex.

        If a secretary is working, they will answer; else, if a landlord is working, they
        will answer; else, no one will answer.
        """
        # This buzzes the office -- if a secretary or landlord is working,
        # have them answer
        try:
            answerer = next(e for e in self.location.working_right_now if e[0] == 'secretary')[1]
        except StopIteration:
            try:
                answerer = next(e for e in self.location.working_right_now if e[0] == 'landlord')[1]
            except StopIteration:
                answerer = None
        return answerer

    @staticmethod
    def _determine_who_answers_buzzer_or_doorbell(dwelling_place):
        """Return a random person who is here to come to the door."""
        if not dwelling_place.people_here_now:
            return None
        else:
            # See if any adults who live here are home -- if any are, return the most
            # extroverted person among them
            adults_who_live_here_who_are_home = [
                p for p in dwelling_place.people_here_now if p.adult and p.home is dwelling_place
            ]
            if adults_who_live_here_who_are_home:
                return max(adults_who_live_here_who_are_home, key=lambda q: q.personality.extroversion)
            else:
                # See if any adults are here, and if any are, return the most extroverted of them
                adults_here = [p for p in dwelling_place.people_here_now if p.adult]
                if adults_here:
                    return max(adults_here, key=lambda p: p.personality.extroversion)
                else:
                    # See if anyone who lives here and is at least five years old is home; if
                    # there is, return the oldest one
                    people_here_who_live_here = [
                        p for p in dwelling_place.people_here_now if p.home is dwelling_place and
                        p.age > 4
                    ]
                    if people_here_who_live_here:
                        return max(people_here_who_live_here, key=lambda p: p.age)
                    else:
                        # See if anyone above age 4 is here; if there is, return the oldest one
                        people_here_above_age_four = [
                            p for p in dwelling_place.people_here_now if p.age > 4
                        ]
                        if people_here_above_age_four:
                            return max(people_here_above_age_four, key=lambda p: p.age)
                        else:
                            return None

    def wait(self):
        """Wait here until the next timestep."""
        self.game.advance_timestep()
        self.game.communicator.speak_directly_to_player(
            "It is now {time_of_day}time.".format(time_of_day=self.game.sim.time_of_day)
        )
        # self.observe()

    def notify(self):
        """Notify interlocutor that the deceased person has died."""
        self.game.communicator.current_logo_src = "bad_news_logo.png"
        self.game.communicator.current_logo_height = "102px"
        # Determine whether the notified person was a next of kin
        if self.interlocutor in self.game.next_of_kin:
            verdict = "You have successfully notified the next of kin. You have delivered the bad news."
        else:
            verdict = "You have notified the wrong person."
        # Express this outcome to the player
        if self.game.offline_mode:
            print verdict
        else:
            self.game.communicator.player_exposition = verdict
            self.game.communicator.player_exposition_enumeration = ''
            if not REMOTE_WIZARD:
                for _ in xrange(10):
                    self.game.communicator.update_player_interface()
            else:
                self.game.communicator.update_player_interface()

    def notify_random_person(self):
        """As a last-ditch effort, notify a random person in the player's location."""
        assert self.location.type != 'block', "The player is currently located on a block."
        self.interlocutor = random.choice(list(self.location.people_here_now))
        self.notify()

    # Wrappers

    @property
    def i(self):
        """Wrapper for self.interlocutor."""
        return self.interlocutor

    @property
    def s(self):
        """Wrapper for self.subject_of_conversation."""
        return self.subject_of_conversation

    def dyk(self, features_str=None):
        """A wrapper around do_you_know()."""
        self.do_you_know(features_str=features_str, narrow=False)

    def atl(self):
        """Wrapper around ask_to_list()."""
        self.ask_to_list()

    def l(self):
        """Wrapper around ask_to_list()."""
        self.ask_to_list()

    def hdyk(self):
        """Wrapper around how_do_you_know()."""
        self.how_do_you_know()

    def list(self):
        """Wrapper around ask_to_list()."""
        self.ask_to_list()

    def hinge(self, address_number=None):
        """Wrapper around talk_about_hinge()."""
        self.talk_about_hinge(address_number=address_number)

    def ap(self, addressee=None):
        """Wrapper around address()."""
        self.address(addressee=addressee)

    def ad(self, house_number=None):
        """Wrapper around approach()."""
        self.approach(house_number=house_number)


# Define various global variables that serve as quick convenience wrappers
# for the wizard to utilize during gameplay
offline_mode = False
bn = Game(offline_mode=offline_mode)
g = bn.sim
pc = bn.player
d = bn.deceased_character
nok = bn.next_of_kin
uai = bn.communicator.update_actor_interface
push = bn.communicator.update_actor_interface
upi = bn.communicator.update_player_interface
test = bn.communicator.test

l = pc.ask_to_list
ta = pc.talk_about
bar = pc.goto_bar

pop = pc.pop_back
go = pc.go_outside
gk = pc.go_knock
ge = pc.go_enter
comm = bn.communicator
ce = bn.communicator.set_player_interface_enumeration_text

bot = g.city.businesses_of_type
sim = g
sibs = list(d.siblings)
mom, dad = d.mother, d.father
loves_d = [p for p in g.city.residents if p.love_interest is d]
institutions = [c for c in g.city.former_companies if c.closed-c.founded >= 75]
institutions += [c for c in g.city.companies if g.year-c.founded >= 75]
institutions = [
    c for c in institutions if c.__class__.__name__ not in (
        'Farm', 'Park', 'Cemetery', 'CityHall', 'FireStation', 'PoliceStation', 'School'
    )
]
def bg():
    if not pc.i:
        print '(no interlocutor)'
    else:
        print "Relation to {} (d): {} (c: {}, s: {})".format(
            d.name, pc.i.relation_to_me(d) if pc.i.relation_to_me(d) else 'none', pc.i.charge(d), pc.i.spark(d)
        )
        for n in nok:
            print "Relation to {} (nok): {} (c: {}, s: {})".format(
                n.name, pc.i.relation_to_me(n) if pc.i.relation_to_me(n) else 'none', pc.i.charge(n), pc.i.spark(n)
            )
        for pci in pc.all_interlocutors:
            print "Relation to {} (i): {} (c: {}, s: {})".format(
                pci.name, pc.i.relation_to_me(pci) if pc.i.relation_to_me(pci) else 'none',
                pc.i.charge(pci), pc.i.spark(pci)
            )
def inst():
    for i in institutions:
        if i.closed:
            print "{name} {founded}-{closed}".format(name=i.name, founded=i.founded, closed=i.closed)
        else:
            print "{name} {founded}-open".format(name=i.name, founded=i.founded, closed=i.closed)

def I():
    for _ in xrange(10):
        upi()
        uai()
def lpush():
    l()
    push()
def let_in_apt():
    """Let the player into the hallway outside the apartment of the person that they're buzzing."""
    if pc.i and pc.i.location.__class__.__name__ == "Apartment":
        apt_number = pc.i.location.unit_number
        pc.enter(let_in=True)
        pc.approach_apt(apt_number)
        pc.knock()


speak = bn.communicator.speak_directly_to_player
begin = bn.begin
epilogue = bn.epilogue
prompt = bn.prompt
bd = pc.view_business_directory
rd = pc.view_residential_directory
out = pc.go_outside
observe = pc.observe
goto = pc.goto
goto_block = pc.goto_block
goto_co = pc.goto_co
go_back = pc.go_back
move = pc.move
approach = pc.approach
enter = pc.enter
exit = pc.exit
address = pc.address
end_convo = pc.end_conversation
ring = pc.ring
knock = pc.knock
buzz = pc.buzz
notify = pc.notify
